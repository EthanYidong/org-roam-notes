:PROPERTIES:
:ID:       0e072874-a2a8-495e-a30e-08ad11990f20
:END:
#+title: CS3235 Notes
#+filetags: :CS3235:

* Typos
:PROPERTIES:
:ID:       71794092-1180-4340-a72d-deb9b527b3ba
:END:
- (Part 1) Symmetric Key Encryption.pptx Page 5: Probabilisitic (mispelled)
- (Part 1) Symmetric Key Encryption.pptx Page 11: Xs fi sv rsx xs fi, Xlex mw xliuyiwxmsr (missing a space)
- (Part 1) Symmetric Key Encryption.pptx Page 19: \(K \rightarrow C\) should be a bijection (actually is a surjection)
- (Part 2) Integrity.pptx Page 11: \(a=0\) (should be 1)
- 9 - Full Mem Safety.pptx Page 30: Deference (should be dereference)
* The Wrench
:PROPERTIES:
:ID:       75bebc21-eb72-480f-8441-1230a1b31d9c
:END:
- [[file:media/wrench_1.png][Relevant XKCD]]
- The goal is to make security a purely physical problem

* Threat Model
:PROPERTIES:
:ID:       1015608c-9304-487f-90dc-eb57f4aca2da
:END:
- Describes the:
  - Desired security property/goal
  - Attacker capabilities
  - Assumptions about the setup
* Network
:PROPERTIES:
:ID:       99bab403-753f-4047-a8fb-0d96f8ff9c9e
:END:
- See [[id:D1F12114-39AC-40DC-98D0-7B6F67DEC041][CS2105 Notes]] for more on networking
** Border Gateway Protocol
:PROPERTIES:
:ID:       2685a286-5c6b-4e45-baaa-26564ca4b415
:ROAM_ALIASES: BGP
:END:
- Algorithm to route between [[id:c3b243ad-3fd8-4d6c-8d86-652e4bd44dce][Autonomous Systems]]
- [[file:media/bgp_1.png][Diagram]]
- Operates through Network Layer Reachability Information updates (NLRI)
** Transport Layer Protocols
:PROPERTIES:
:ID:       0110d185-9e62-4645-84cf-779dbbd87024
:END:
- UDP: unreliable
- TCP: reliable, strictly ordered
** Network Security
:PROPERTIES:
:ID:       65dfd478-db38-4a81-9ee6-6cb5e7e7bf00
:END:
- Network Attacker types:
  - Eve (eavesdropper): can see all traffic
  - Mallory: can see, edit, spoof, and drop all traffic
- Example: Exploiting [[id:2685a286-5c6b-4e45-baaa-26564ca4b415][BGP]]
  - Route hijacking
  - A gateway pretends that it can directly reach all other ASes
  - When this information is propagated, other devices routing tables will route through that gateway, thus all traffic will be sent through it
- Example: [[id:c66bc940-0321-468b-86c1-21ae30542ab4][IP]] protocol
  - Core weakness: changes made to the packet are undetectable
  - Attacks on confidentiality: packets can be sniffed
  - Attacks on integrity:
    - IP Data pollution
    - Source IP forgery
      - Used for DDoS
        - Smurf attack via ICMP protocol
        - [[file:media/smurf-attack_1.png][Diagram]]
      - Anonymous infection (e.x. Slammer Worm) is possible
        - Random source IP address means receiver cannot tell who is sending the virus
** TCP
- See [[id:458a323f-763b-458e-9ce8-7b7fb008a473][TCP]]
- Example: Predictable sequence numbers
  - [[file:media/predictable-sequence_1.png][Diagram]]
  - Open a connection as a spoofed IP address
  - Guess what sequence number was generated by the server
  - Send an ACK packet for that guessed sequence number
  - This breaks IP-based authentication which is still commonly used
** DNS
- See [[id:a3ae3cdc-5328-402e-8c47-177e942fa4fb][DNS]]
- Example: modifying in-transit DNS responses
  - Must be in between the server and the client
  - Edit the responses
- Example: DNS cache poisoning / pharming
  - DNS requests are attached to a "query ID" QID
  - In some implementations, QID is sequential / easily predictable
  - [[file:media/dns-cache-poisoning_1.png][Diagram]]
  - Results in a race between two packets
    - If you lose, correct answer will be cached
    - But eventually the correct answer is dropped from the cache and you can try again
    - Or, if you have code running on the user machine like javascript, you can manually force the cache to flush by sending requests to many different domain names
* Firewalls
:PROPERTIES:
:ID:       9eeb8562-355b-429b-9086-a374d2907f01
:END:
- See [[id:fdb9fb22-cc48-4eab-a86f-c43d83b8d827][Firewalls]]
- Operates at the border between networks
- Network level firewalls operate at the TCP/IP layer
- Application level firewalls operate on higher layers
  - Network Intrusion Detection systems (NIDS)
  - Intrusion Prevention Systems (IPS)
** Stateless Packet Filter
:PROPERTIES:
:ID:       a271bd8c-f7c8-4295-89fb-52031d751e40
:END:
- Filters based on IP and transport-level headers such as source/destination IP, protocol, ports, etc.
- [[file:media/stateless-filter_1.png][Diagram]]
- Good practice: deny by default (default deny rule)
** Stateful Packet Filters
:PROPERTIES:
:ID:       a5ab9be3-b389-4267-a333-0f1970da6621
:END:
- Works on connection-level protocols like TCP
- Maintains data about connection state and makes decisions based on it
** Proxy-based / Application Firewalls
:PROPERTIES:
:ID:       7d29626b-037c-4298-926a-f89d73199747
:END:
- Understands application logic
** Netfilter
:PROPERTIES:
:ID:       9ce420bf-8ec0-469d-82b8-e55ee167d5c5
:END:
- Linux kernel packet filtering framework
  - Prerouting
  - Postrouting
  - Forward
  - Input
  - Output
- ~iptables~ to view existing rules
** Firewall Threat Model
:PROPERTIES:
:ID:       a3b76440-040c-4869-aa0a-50da6593f00b
:END:
- Stop malicious packets from reaching the end application
- Adversary capability:
  - Adversary can send malicious/arbitrary packets
  - Firewall is between adversary and end application (i.e. adversary is outside the network boundary)
- Assumptions:
  - Firewall is working properly and is correctly configured
  - Firewall sees the same data as the application
  - Network boundary is correctly defined
- Issues:
  - Adversary is assumed to follow a specific attack pattern which can be detected by firewall
  - Firewall can inspect individual bytes but a stateless firewall can be tricked by splitting the packet
  - Encrypted (HTTPS) is hard to work with
* Secure Channel
:PROPERTIES:
:ID:       c8752aaf-6c8d-4130-8e6e-104a2897b5e3
:END:
- A secure channel preserves [[id:42696A4B-0DFA-435B-858E-D061FEB2CCA0][Confidentiality]], [[id:1FE1E862-1BEC-409A-93BB-7CBF73FACB14][Integrity]], and [[id:4ef52bfb-193b-4fee-8332-33018153a3a3][Authentication]]
- Examples
  - HTTPS
  - SSH
  - VPN
- [[file:media/secure-channel-setup_1.png][Setup]]
- How to defeat this adversary?
  - We could assume that their network is weaker than Alice and Bob's connection
  - Or we can assume that Alice and Bob have some pre-shared information that Mallory does not have
** Encryption vs Confidentiality
:PROPERTIES:
:ID:       ca28ba88-be38-4305-a048-dfaff2a40518
:END:
- Confidentiality is the goal/property, encryption is the method by which you achieve it
- [[file:media/achieve_1.png][Diagram]]
** Network Attacker
:PROPERTIES:
:ID:       fbf3ad26-d837-4f2e-b85c-1ca5b139d173
:END:
- Eve is assumed to only eavesdrop on traffic
- Mallory can modify and create traffic as well
** Symmetric Key Encryption
:PROPERTIES:
:ID:       9980e513-c6a2-49f5-befb-f129d7f3217d
:END:
- Defined by:
  - \(Setup: \rightarrow K\)
  - \(Enc: M \times K \rightarrow C\)
  - \(Dec: C \times K \rightarrow M\)
- Correctness: \(\forall m, k, Dec(Enc(m, k)) = m\)
- Security:
  - How do we mathematically define it?
  - Attacker can't guess the message, key, or ciphertext?
  - These depend on what the adversary knows beforehand
  - \(Pr[Guess = m | c] = Pr[Guess = m]\)
- Adversary knows:
  - How the Setup, Enc, Dec functions work
    - Randomness is not known
  - A distribution over M from background knowledge
    - Defender does not know this distribution
  - In addition, we may have a [[id:60ec3e66-6409-439b-98c8-eeaf7c84ea9b][Chosen Plaintext Attacker]]
*** Chosen Plaintext Attacker
:PROPERTIES:
:ID:       60ec3e66-6409-439b-98c8-eeaf7c84ea9b
:END:
- On top of base knowledge, adversary is also able to generate ciphertexts for any arbitrary m
*** One Bit Encryption
:PROPERTIES:
:ID:       91391358-9ef9-4eb2-bde3-701a0c9c0c7b
:END:
- \(m, k, c\) are all \(\{0, 1\}\)
- What function satisfies our conditions?
- Answer: XOR (or XNOR)
*** One Time Pad
:PROPERTIES:
:ID:       fe0fec92-bb87-4263-a0a8-4e2b36089b31
:END:
- \(Enc: c := m \oplus k\)
- \(Dec: m := c \oplus k\)
- Why does this work?
  - By fixing \(k\), Enc/Dec is a bijection between \(m\) and \(c\)
  - Adversary cannot distinguish \(m=0\) and \(m=1\)
- Proof
  - Let \(m \in {0, 1}\) be with \(Pr[m=0] = p\) and thus \(Pr[m=1] = (1-p)\). \(p\) can be aribtrary and chosen by the adversary.
  - \(Pr[m=0 | c=0] =  \frac{Pr[m=0 \cap c=0]}{Pr[c=0]} = \frac{p}{2} \div \frac{1}{2} = p\)
  - Likewise, for the other cases, probability is the same
- Limitations of the one time pad:
  - Large key space
    - However, note that for any cipher to satisfy perfect secrecy, \(|K| \geq |M|\)
    - Fix the key, then \(M \rightarrow C\) is a bijection for correctness
    - Then, \(|M| = |C|\)
    - Fix the message, then \(K \rightarrow C\) is a surjection
    - Then, \(|K| \geq |C|\)
  - Key cannot be reused
** Message Authentication Codes
:PROPERTIES:
:ID:       2d8a17ec-4181-4f47-9def-9dd61f2ef592
:END:
- Sender authenticity: sender can be verified to know the pre-shared key
- Message integrity: any changes to the message can be detected
- Defined by:
  - \(S(k, m)\) outputs \(t \in T\)
  - \(V(k, m, t)\) outputs 'yes' or 'no'
*** Chosen Message Attack
:PROPERTIES:
:ID:       a2e9d206-8639-4488-abb5-2fc57274569b
:END:
- Attacker can ask to generate \(t\) for any \(m\)
- Attacker must then be able to generate themselves \(t'\) for an \(m'\) which they have not seen before
*** One Bit MAC
:PROPERTIES:
:ID:       c87a0bb8-6ab4-4689-a0ab-0e12629201c2
:END:
- Tag space is \(|T| = 2^n\)
- Try \(n = 1\)
- \(S(m, k)\)?
  - \(m\)? No, we can easily forge a message
  - \(m \oplus k\)? No, we can use the message to derive \(k\)
  - Answer: \((a \cdot m + b) mod p\)
    - Note: when \(a=0, b=k, p=2\), this is the XOR function
    - \(p\) is a publically known prime
    - \((a, b)\) is the pre-shared key
    - Example: given that \((m, t) := (0, 1)\),
      - We don't know if the key is \((0, 1\) or \((1, 1)\)
      - And, those keys give different results for \(m'=1\)
      - Formally, \(Pr[S_{a,b}(m) = t \wedge S_{a,b}(m')=t'] = \frac{1}{|T|^2}\) for fixed \(m, m', t, t'\) and random across (a, b).
      - In other words, every single tag result set is equally likely
- Keys should be 2n bits for a n bit MAC, i.e. \(|K| \geq |T|^2\)
  - Proof: For any message-tag pair, how many keys give us \(S_{k}(m) = t\)? Define this set as \(K(m, t)\)
  - Claim: \(\forall(m_0, t_0), \frac{|K(m_0, t_0)|}{|K|} \leq \frac{1}{2^n}\)
  - Assume this is false, then for a random pair of chosen keys, \((m_0, t_0)\) is valid with probability \(p > \frac{1}{2^n}\)
  - We can forge a tag for \(m_1\) by randomly choosing a key in the possible key space
  - \(Pr[\text{Success}] \geq \frac{1}{|K(m_0, t_0|} = \frac{2^n}{|K|}\) since at least one of the keys is correct
  - We also want \(Pr[\text{Success}] \leq \frac{1}{2^n}\)
  - Thus \(|K| \geq 2^{2n}\)
** Computational Hardness
:PROPERTIES:
:ID:       78ba1b3d-7151-4d67-94dd-3b136e549b6c
:END:
- Perfect secrecy needs impractical key lengths
- How do we build practical cryptographic schemes?
- Assume that the adversary is limited in terms of computing power
- Thus, we build our algorithms using "hard to solve" problems
- Our symmetric encryption becomes: \(Enc(k, m) := PRG(k) \oplus m\)
  - \(PRG\) is a pseudo-random generator
- Assume: unlike the case in [[id:60ec3e66-6409-439b-98c8-eeaf7c84ea9b][Chosen Plaintext Attacker]], that the attacker has limited computational power, also known as an "efficient" attacker
  - This adversary can be modeled by an arbitrary algorithm
  - Must be polynomial in time
  - Randomized, non-deterministic execution
  - Bounds queries in a [[id:60ec3e66-6409-439b-98c8-eeaf7c84ea9b][Chosen Plaintext Attacker]] to polynomial in \(|K|\)
*** One-Way Functions
:PROPERTIES:
:ID:       dab3a043-ebff-44e0-9f82-011df3a40e64
:ROAM_ALIASES: "Practical Encryption Constructions"
:END:
- A function which is easy to compute but hard to invert
- It allows us to build Pseudorandom generators (stream cyphers), cryptographic hash functions, pseudorandom permutations (block cyphers)
*** Practical MAC Constructions
:PROPERTIES:
:ID:       22e9159e-19d6-499d-b0ba-921f982c20d4
:END:
- Cryptographic hash function: HMAC
- PRP/PRF block ciphers: OMAC, CCM, PMAC
** Asymmetric Key Cryptography
:PROPERTIES:
:ID:       b218307d-eebe-4a02-9961-447bd2a9105f
:ROAM_ALIASES: "Public-Key Cryptography"
:END:
- Two mathematically linked keys are used: a public key which is freely shared and a private key which is kept secret
- Generally, public key is used for encryption and private key is used for decryption
*** Digital Signature
:PROPERTIES:
:ID:       3c039cfb-2969-4f87-8bb8-8423e705a7ff
:END:
- Instead of encrypting with the public key, you encrypt with the private key and anyone can attempt to decrypt it
- Getting a valid output indicates that the message author knows the private key
*** Practical PKC Constructions
:PROPERTIES:
:ID:       9d04fa58-16d7-47aa-a496-5e5596952a2c
:END:
- Using [[id:78ba1b3d-7151-4d67-94dd-3b136e549b6c][Computational Hardness]]
  - Difficulty of finding large primes ([[id:036994b9-0dff-4b8e-adea-283df9012d31][RSA]])
  - Discrete Logarithm in Groups (ElGamal)
  - Problems in Lattices
    - Post-Quantum
** Key Exchange Protocol
:PROPERTIES:
:ID:       736ea3c4-b1c6-41b7-8dde-17af41ccc76a
:END:
- A way to create new shared secrets
- Forward secrecy: Even if long term shared key is compromised, sessions are still protected
*** Discrete Log
:PROPERTIES:
:ID:       dda75ccf-7cba-47ae-afd2-57a93dc2c385
:END:
- For an appropriately chosen group \(G\)
- We have a generator \(g\) such that repeatedly applying the operator to \(g\) will eventually yield all element in \(G\)
- For example, multiplication modulo some prime.
- Given \(A \in G\), it is hard to find \(a \in G\) such that \(g^a = A\)
- However, given \(a\), we can compute \(A\) in logarithmic time
*** Diffie Hellman
:PROPERTIES:
:ID:       6e6c565a-93c7-40e1-844a-53efcffa6111
:ROAM_ALIASES: CDH
:END:
- A [[id:736ea3c4-b1c6-41b7-8dde-17af41ccc76a][Key Exchange Protocol]] which employs a problem similar to [[id:dda75ccf-7cba-47ae-afd2-57a93dc2c385][Discrete Log]] as its "hard problem"
- Alice and Bob agree on a \(g\) and a \(p\)
- They pick random numbers \(a\) and \(b\).
- Alice sends \(g^a\), Bob sends \(g^b\)
- Both parties are now able to compute \(g^{ab}\), but [[id:28DAED70-FF28-43A9-AABE-A1FC13D0A639][Eve]] cannot.
  - She has to solve [[id:6e6c565a-93c7-40e1-844a-53efcffa6111][CDH]] to crack the key
- However, [[id:C6BD6271-3B92-4538-9398-FCCA53B7A1B5][Mallory]] can break this protocol
  - [[file:media/diffie-hellman-attack_1.png][Diagram]]
**** Computational Diffie Hellman
:PROPERTIES:
:ID:       3b0dbc84-5ea6-42df-8675-3703ded93bd8
:END:
- Solve the problem: given \(g, g^a, g^b\), find \(g^{ab}\)
- If [[id:dda75ccf-7cba-47ae-afd2-57a93dc2c385][Discrete Log]] is easy to solve, than [[id:3b0dbc84-5ea6-42df-8675-3703ded93bd8][Computational Diffie Hellman]] is easy to solve.
- So, if [[id:3b0dbc84-5ea6-42df-8675-3703ded93bd8][Computational Diffie Hellman]] is hard, then [[id:dda75ccf-7cba-47ae-afd2-57a93dc2c385][Discrete Log]] is hard.
*** Station-to-Station
:PROPERTIES:
:ID:       28f0be11-63e0-4fe5-8ef2-47ff6ccbcc02
:END:
- Fix [[id:6e6c565a-93c7-40e1-844a-53efcffa6111][Diffie Hellman]] by adding [[id:3c039cfb-2969-4f87-8bb8-8423e705a7ff][Digital Signature]]
- Requires pre shared keys
- [[file:media/station-to-station_1.png][Diagram]]
** HTTPS
:PROPERTIES:
:ID:       406b5c5c-ab3a-499a-b830-60dc4e516894
:END:
- HTTP + SSL/TLS
- High level steps:
  - Negotiate to figure out which cipher suites should be used
  - Run an authenticated key exchange like [[id:28f0be11-63e0-4fe5-8ef2-47ff6ccbcc02][Station-to-Station]]
  - You end up with a shared secret key
  - The rest of the communication is secured using that key
    - Symmetric cryptography is faster and smaller to run
  - Renegotiation is possible (although depreciated)
- But how do we know what public key to use for authenticated key exchange?
  - The other party sends it to you, but how do you know it's legitimate?
  - Certificate signing can allow you to trace a legitimate public key to be "trusted" by some root CA
  - Root CA signs a certificate allowing an entity to sign a limited set of domains like *.google.com
  - That intermediate CA may then sign a certificate for the actual endpoint like mail.google.com
- [[file:media/tls_1.png][TLS Diagram 1]]
- [[file:media/tls_2.png][TLS Diagram 2]]
- Alternative using [[id:6e6c565a-93c7-40e1-844a-53efcffa6111][Diffie Hellman]]:
- [[file:media/tls-dhe_1.png][TLS with DHE]]
*** Arguments for HTTPS
:PROPERTIES:
:ID:       7e7a74a9-6a04-411d-a4b9-427159892175
:END:
- State threat model: what are your assumptions?
  - User is using a secure channel
  - Crypto primitives are secure
  - TLS protocol design is secure
  - TLS protocol implementation is secure
  - Certificate issuers are uncompromised
  - Users check browser UI correctly
  - (from me) Browser UI displays information correctly
  - Alice & Bob's secrets are secure
  - Entities are authenticated correctly
** Secure Channel Weaknesses
:PROPERTIES:
:ID:       9e35e273-28f2-4046-bcfd-0103ee3c81c2
:END:
- Go outside the threat model
  - Attack the assumptions
  - Violate security properties not covered by the model
*** [[id:406b5c5c-ab3a-499a-b830-60dc4e516894][HTTPS]] Weaknesses
:PROPERTIES:
:ID:       bd401730-eef5-4fa3-9886-d7075e395518
:END:
- HTTPS is even being used
  - Attacker could inject downgraded links into an insecure page
  - Insecure requests to HTTP resources like JavaScript scripts
    - Even if it's a requests to a more harmless object like image, the browser will attach non "Secure" flagged cookies to the HTTP request allowing attackers to spoof your login session
  - Secure resources loaded from an insecure page: attacker can replace the URL of secure resources with spoofed ones
  - Defence Mechanisms
    - HSTS: HTTP Strict Transport Security
      - Server lets browser know that it only serves HTTPS content
      - Browser remembers this and will no longer send HTTP requests to the server no matter what
      - Some browsers have preloaded lists of HTTPS-only websites
    - Secure flag cookies
      - Cookies which will only ever be sent over HTTPS
      - However, HTTP headers can still set the cookies without HTTPS
      - JavaScript can also access and modify the cookies
- User Checks UI Properly
  - Misleading URL
    - If the browser URL looks correct but is slightly off then it could be owned by an attacker trying to spoof the website
  - Clickjacking
    - Overlay an iFrame of another webpage, lower the opacity or hide it in some other way
    - When user clicks on visible elements in the webpage, they unknowningly interact with a different website that they may be authorized to
  - HTTP Content in HTTPS pages
    - Attackers can replace certain components that are being loaded via HTTP, if they are scripts then they essentially gain full access to the page
    - Legacy browsers would somewhat indicate that the webpage was not fully secured
    - Now requests are mostly blocked
  - Clickthrough
    - When browser warns users of insecure site certificate, user may choose to click through
- Certificate Issuers are Uncompromised
  - Root CAs
    - Issue certificates after checking ownership of a certain domain (usually via a challenge to edit/add a page to that domain)
  - Custom CA
    - Start self-signing certificates
    - Sometimes installed in client/worker machines
  - CAs get compromised
    - Then whoever gets their private key can break HTTPS for any site
    - How do defend?
      - Pinning
        - "Trust on first use"
        - When the user first visits the site the certificate is remembered, then changes are reported
        - May end up with a large list
        - How to deal with valid certificate changes?
      - Revocation
        - Some additional infrastructure allows CAs to revoke bad certificates
        - OCSP maintains a list of invalidated certificates
        - Using Stapling, websites can prove that their certificates are still known as valid
        - Takes time to discover rogue certificates
        - Attacker may just re-request a certificate
      - Transparancy
        - Publicly audit all SSL certificates
        - Create registry of all SSL certificates which users have encountered
        - Server must be correct and reliable
        - How to maintain privacy?
- Side Channel Leakage
  - Information may get leaked via [[id:2fc854d5-befd-402b-823c-0c57c8deb2aa][Side Channel Attack]], when data gets leaked through some method not designed as the primary communication
  - In practical world, your program must touch some side channel which attackers can use
  - Assumptions:
    - Attacker knows program details
  - Possible side channels:
    - Size of data
    - Timing
    - Data access patterns
    - Power
    - Sound
    - EM radiation
- Underlying Crypto Primitives
  - MD5 is insecure
  - Provide integrity + authenticity?
    - MAC can leak data
    - So Encrypt with MAC is insecure
    - Encrypting a MAC may allows attacker to edit the MAC in a way that leaks data, depending on the exact schemes chosen
      - Conduct a [[id:0920a4ca-e492-441e-85d7-b6d7805782c3][Padding Oracle Attack]]
    - MAC of an Encryption is provably secure

* Memory Safety
:PROPERTIES:
:ID:       ba194276-7701-4e38-b54a-b7f4179e3ef4
:END:
- C and C++ give maximum control over memory to programmers
- but they also give maximum control to memory to programmers
- Developers may make mistakes, and when those mistakes affect the memory of the program bad things may happen
- Programs written in low-level (especially operating systems) are most vulnerable
** Spatial Memory Safety
:PROPERTIES:
:ID:       fdbec1c2-35a5-4a58-91c8-5f4101f1cd9f
:END:
- Buffer Overflows occur when the computer attempts to write beyond the boundaries of a preallocated buffer
  - This may end up editing memory which was not intended by the programmer
- Printf/scanf
  - [[file:media/c-io_1.png][Semantics]]
  - For security, printf and scanf format strings /should/ be constants or verified by the program in some way
  - The function uses the format string to determine how many arguments it should expect on the stack
  - However, if it is affected by user input, we can enter a string like "%08x %08x %08x %08x..." to leak data from the calling stack (%08x prints a number in 8-digit hex)
    - Note: in x64, the first 5 arguments are passed by register (so we need to throw away the first 4 values)
- Integer Overflow
  - When the result of an operation is too large to stored in the specified data type, unspecified behavior is run to handle the overflow
  - This will lead to unexpected behavior (for example, if you store string length in an integer which is too small, you may get a smaller value than the actual length of the string)
    - This can lead to buffer overflow attacks
- Code Injection / Control Hijacking
  - Often, attackers can buffer overflows to override the saved return address on the stack, allowing them to control which address gets executed after the function returns
  - In other cases, it may point to user-writable buffers so that the attacker can write their own code to be executed
    - That code is called shellcode
    - [[file:media/shellcode_1.png][Shellcode]]
    - What happens when you don't know the exact address of the buffer?
    - NOP sled: prepend a lot of NOP instructions (0x90) to the shellcode
    - That instruction does nothing
    - Then, as long as any of these instructions is returned to, your inteneded shellcode will be run (you can jump anywhere in the NOP sled)
    - Requires:
      - Attack payload can be written in memory
      - Attack payload can be executed
      - Control flow can be diverted to payload
- However, sometimes it is impossible to write to executable locations
  - So, use existing code in memory
  - Example: return-to-libc
    - Set the return address to wherever the function you want to run is (for example, ~execve~)
    - Use the buffer to pass your desired parameters to the function
    - [[file:media/return-to-libc_1.png][Example]]
  - This drops the requirement that your payload must be written by you in executable space
  - You can extend this further with return-oriented-programming
*** Heap Overflow
:PROPERTIES:
:ID:       2b0270ea-12f7-496a-8bf0-724aebe083f8
:END:
- glibc manages memory allocation in C
- Chunks of memory which are allocated are stored in a linked list
- Chunks of memory which are unallocated are stored in another linked list
- [[file:media/heap-ll_1.png][List]]
- [[file:media/heap-overflow_1.png][Overflow]]
- We can use this to overwrite function pointers and achieve similar results as the stack overflow overwrite of return pointer
*** Data-Oriented Attacks
:PROPERTIES:
:ID:       6d9a0e85-87a6-4d5f-b648-9ae2ca0f4810
:END:
- Oftentimes we do not need to write any control data to conduct an exploit
- For example, if there is security-critical data stored in memory, we can use buffer overflows to overwrite it and make the program behave unexpectedly
- Sometimes, overwriting existing data isn't necessary:
  - Heartbleed bug in OpenSSL
  - "Heartbeat message", echo the [x] characters [...]
  - What happens when [x] is set incorrectly?
  - OpenSSL would overread the data in the buffer and potentially leak some sensitive data
*** Bad-Casting
:PROPERTIES:
:ID:       910fe173-7b5b-4dc9-87cb-01b1263e4c22
:END:
- [[file:media/cpp-cast_1.png][Casting]]
- Contents of a base class is right above the pointer to the instance of the inherited class
- Upcasting (derived to base) is always safe (if other assumptions hold)
- However, by downcasting, your new pointer may not point to a valid instance of the expected type
- [[file:media/downcast_1.png][Downcast]]
- Can prevent by utilizing dynamic casts
** Temporal Memory Safety
:PROPERTIES:
:ID:       212b62b3-72b3-489a-a26a-350c84be6da9
:END:
- [[file:media/scope_1.png][Scope]]
- Variables have scope and a lifetime (behavior defined by language)
- Variables can expire, meaning that the memory allocated to them is marked as no longer in use
  - Variable storage is only guaranteed across the lifetime of the variable
- In C/C++:
  - Scope is defined by blocks delimited by curly braces
  - Lifetime of variables last for the rest of the scope it was defined in
*** Use-After-Free
:PROPERTIES:
:ID:       d75c8970-115d-4a73-844c-9cccc5ead6fc
:END:
- When a pointer points to a memory location of a variable, then that variable gets freed, the pointer is now a dangling pointer
- Attempting to access that memory location (for example, by a dangling pointer), leads to undefined behavior
*** Double Free
:PROPERTIES:
:ID:       42e6c359-0485-44d2-b215-0ecd1227ab5e
:END:
- [[file:media/double-free_1.png][Double Free]]
- What happens when you run free on the same heap allocation twice?
- The linked list pointers representing the allocation may have already been overwritten with arbitrary data.
- Then, when attempting to free again, the compiler will used the overwritten pointers to attempt to "join" the linked list
- This allows for writing arbitrary data to arbitrary locations in memory
- [[file:media/write-anywhere_1.png][Diagram]]
** Mitigations
:PROPERTIES:
:ID:       f6f7a2c5-0be5-4768-8b96-227fcb9bfd76
:END:
- Use safe programming practices
  - Safe libraries
  - Use automated bug finding tools
  - Use safe functions like strncpy over strcpy
- libsafe: replaces calls to insecure operations like strcpy with validated alternatives
- Code checking:
  - Address Sanitizer
  - ITS4
  - RATS
  - Flawfinder
- Stack canaries
  - Store random values on function stack frames which are checked before returning from functions
  - Helps detect corruption of nearby memory addresses
- Guard pages
  - Insert pages with no read, write, or execute permissions scattered throughout the memory space
  - Attacker can only write linearly if using buffer overflows, and thus would trigger a fault if attempting to write to one of these pages
- Non-executable data (DEP)
  - Set writable regions like the stack as non-executable (prevents shellcode attacks but not ROP attacks)
- Address randomization (ASLR)
  - By randomizing the address space, attackers cannot easily predict locations of important items such as where libc is stored
** Enforcing Memory Safety
:PROPERTIES:
:ID:       67a17e2d-2f68-4e7e-b957-beaa517a3a98
:END:
- Create memory pointers via permitted operations (malloc, &)
- Pointer should only allow access to a specific range of memory (spacial) and only across a valid scope (temporal)
- All "objects" should be spatially disjoint at all times
  - Sub-structures allowed
  - C union-type overlaps of memory
- How to enforce?
  - Become crab, use Rust
  - Compile-time checks or rewrite the binary file
  - Objects and pointers will be associated with metadata to assist with these checks
  - Inline Reference Monitors (IRM)
  - Metadata must also be protected to only be accessed by monitors
*** Enforcing Spatial Memory Safety
:PROPERTIES:
:ID:       7e077120-8bc5-4b14-a644-c2bc4157cb3e
:END:
- Each object or pointer knows its memory bounds
- When pointers access the object, we check that the memory accessed falls in the valid range for that pointer
- Bounds metadata should be stored where?
- Keep an indexing table in a protected region of memory (kept without R/W permissions until needed to be used)
  - Do we associate the bounds with the pointer, or with the object?
  - Fat pointer: pointer associated with the metadata
  - Referent objects: object associated with the metadata
- Referent objects:
  - When pointers change, check if it is within the bound. If it is, mark as safe. If not, mark as unsafe.
    - Pointers can become safe again after being marked as unsafe
  - How to handle overlapping objects?
    - If we index by memory address then we cannot deal with two objects with the same start but different bounds
- Fat pointers:
  - Bounds are tracked on allocation
  - Bounds are checked on dereference
  - No need to check pointer arithmetic
  - Now, pointers that point to the same address can now be distinguished because bounds are assigned on creation based on what type the new pointer is referencing
  - No need to check type-casts
  - Also prevents issues from badcasts
  - [[file:media/fat-pointer-badcast_1.png][Badcasts]]
- [[file:media/checking-tradeoffs_1.png][Tradeoffs]]
- Problem: dynamic checking is costly (100%++ overhead)
*** Static Checking
:PROPERTIES:
:ID:       2b52f09f-ec63-45a5-9baf-b03555e8d76c
:END:
- Reduce runtime overhead by doing checks at compile time
- [[file:media/static-check_1.png][Static Checking]]
- y is statically checkable (as long as a is statically checkable) because it is simply just a + 10 for the whole duration of the code
- x may be statically checkable depending on what techniques are being used, with enough analysis it is provable that it is valid on the whole range of a to a + 10
- r is a typecast pointer from some address, so it is hard to check statically
*** Enforcing Temporal Memory Safety
:PROPERTIES:
:ID:       63381f4c-dac9-47da-bec2-ae3e2f91977e
:END:
- Must track the creation and destruction of pointers
- De-allocated memory is not accessed
- Idea 1: NULLIFY pointers
  - When pointer is freed, set it to NULL
  - We can have multiple pointers pointing to the same memory
- Lock and Key mechanism
  - Each pointer has a key and a pointer to a lock
  - Key is freshly generated for each object
  - Value stored at lock address is equal to key
  - Pointers created from this pointer inherit the same key and lock values
  - On dereference, key must equal value stored at lock
  - On deallocation, lock value is changed
  - When key is not equal to value stored at lock, we know that the pointer is now invalid
*** Smart Pointers
:PROPERTIES:
:ID:       6e3b504e-e5eb-4699-a32d-2492144eb913
:END:
- Smart pointers are wrappers of normal pointers
- They can allocate and deallocate automatically and keep metadata about the resource
- In C++: unique_ptr
  - Only one owner can point to the object at any given time
  - Provides temporal safety by only having one pointer referring to an object at any given time
- In C++: shared_ptr
  - Uses reference counting to support multiple pointers
  - Resource is freed only when count is zero
- But, what about concurrency?
- Rust my beloved
  - Statically checked borrows
  - Allow any number of immutable borrows OR one mutable borrow at any given time (enforced by compiler) to provide memory safety even in the presence of concurrency
** Second Line of Defense
:PROPERTIES:
:ID:       d777801b-8266-4779-89cc-c1cd1ad4b087
:END:
- Minimize the damage done by memory safety vulnerabilities
** Reference Monitor
:PROPERTIES:
:ID:       5ba90eb1-dcae-4365-ac89-7bbf87df54de
:END:
- A piece of code which checks all references to an object
- Could be in kernel (system call sandboxing) or program space (inline reference monitoring)
*** Inline Reference Monitor
:PROPERTIES:
:ID:       32cd3bb0-4a52-4e89-89ba-f17934f9987c
:END:
- Either during compilation or by rewriting the binary: add code to check for referencing
- Fault Isolation: only allow a module to access pre-determined data/code
- Problem: Attacker and checker are running at the same privilege level
  - If the memory accesses are limited to a specific region M, then this mechanism should operate under the assumption that the attacker controls all memory in M
- [[file:media/naive-sfi_1.png][Naive Implementation]]
- [[file:media/fast-sfi_1.png][Fast Implementation]]
- How to prevent jumping directly to the mov instruction?
  - Use a dedicated register that only gets used for memory dereferencing, named reg1
  - Every time reg1 is written to before used in the mov command, run the same check/coercion on it, thus enforcing the invariant that reg1 falls on the correct range
- We must ensure:
  - IRM instructions exist before all memory accesses
  - All memory accesses use the dedicated register
  - The dedicated register is only used in IRM instructions
- SFI has a small [[id:3828cca8-0804-4242-ad7f-271f35a67b46][TCB]]
*** System Call Sandboxing
:PROPERTIES:
:ID:       30ea9de1-7a1f-4393-b11a-036fa1f3695c
:END:
- Exec syscall is used by attackers to gain shells, but it's weird from the computer's point of view to run exec straight after taking input
- Can we write policies like "No exec system call" or "No exec-after-read system call"?
- Linux: use seccomp
  - Only allow limited syscalls: exit, sigreturn, read, write
  - In most cases, far too limited
  - seccomp-bpf: configurable policy
  - Can restrict to certain arguments
- Upholds the principle of [[id:c6c1722e-cbac-412c-89db-57bd02fcdfda][Least Privilege]]
- Allow-list (whitelist) vs block-list (blacklist)
  - Similar to [[id:9eeb8562-355b-429b-9086-a374d2907f01][Firewalls]] setup, whitelist is preferred with deny by default
  - If you miss something, your program crashes v.s. your program has a vulnerability
* Systems Programming
:PROPERTIES:
:ID:       818bd0d6-d60e-4de4-9d32-2272eea4401c
:END:
- CPU keeps an "instruction pointer" register which points to the memory location of the next line of assembly to run (EIP)
- The CPU also helps you maintain a stack, with the stack pointer pointing to the head of the stack (ESP), and a frame pointer pointing to the base of the current frame's stack (EBP/RBP)
- Stack grows from high to low memory and stores variables with known sizes
- Heap grows ferom low to high memory and stores variables with dynamic sizes
- [[file:media/x86-memory_1.png][Memory]]
- Intel is "little endian", meaning least significant bytes of multi-byte primitives are in lower addresses (endianness does not affect arrays)
- See [[id:1e0a4e58-4815-44c6-8872-000dd5c6e8b4][Stack Frame]]
* Trusted Computing Base
:PROPERTIES:
:ID:       3828cca8-0804-4242-ad7f-271f35a67b46
:ROAM_ALIASES: TCB
:END:
- The part of the code you assume is bug-free
- Principle: we should minimize the TCB
* Least Privilege
:PROPERTIES:
:ID:       c6c1722e-cbac-412c-89db-57bd02fcdfda
:END:
- Principle: each component should have the minimal set of capabilities needed to carry out its job
** Privilege Separation
:PROPERTIES:
:ID:       a808a688-344d-4098-92a0-2dc9f5c9b4c8
:END:
- Problem: functionality is all bundled together
- For example, an SSH server is in charge of talking to network users and accessing the filesystem
- These are two separate functionalities but they are coupled together in the same code
- If an attacker compromises the network component, they can also now read arbitrary files on the filesystem
- Separate the processes into network and filesystem
- Use sandboxing to constrain each process to its minimal set of syscalls/capabilities
- Case Study: Web Browsers
  - We have an app that reads arbitrary data from the network and must be able to access the filesystem
  - Auto-patching
  - Privilege separation of rendering (HTML, JS, styling) v.s. kernel (filesystem, downloads, cookies, caches)
  - [[file:media/chrome_1.png][Chrome]]
