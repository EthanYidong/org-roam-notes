:PROPERTIES:
:ID:       0e072874-a2a8-495e-a30e-08ad11990f20
:END:
#+title: CS3235 Notes
#+filetags: :CS3235:

* Typos
:PROPERTIES:
:ID:       71794092-1180-4340-a72d-deb9b527b3ba
:END:
- (Part 1) Symmetric Key Encryption.pptx Page 5: Probabilisitic (mispelled)
- (Part 1) Symmetric Key Encryption.pptx Page 11: Xs fi sv rsx xs fi, Xlex mw xliuyiwxmsr (missing a space)
- (Part 1) Symmetric Key Encryption.pptx Page 19: \(K \rightarrow C\) should be a bijection (actually is a surjection)
- (Part 2) Integrity.pptx Page 11: \(a=0\) (should be 1)
* The Wrench
:PROPERTIES:
:ID:       75bebc21-eb72-480f-8441-1230a1b31d9c
:END:
- [[file:media/wrench_1.png][Relevant XKCD]]
- The goal is to make security a purely physical problem

* Thread Model
:PROPERTIES:
:ID:       1015608c-9304-487f-90dc-eb57f4aca2da
:END:
- Describes the:
  - Desired security property/goal
  - Attacker capabilities
  - Assumptions about the setup
* Network
:PROPERTIES:
:ID:       99bab403-753f-4047-a8fb-0d96f8ff9c9e
:END:
- See [[id:D1F12114-39AC-40DC-98D0-7B6F67DEC041][CS2105 Notes]] for more on networking
** Border Gateway Protocol
:PROPERTIES:
:ID:       2685a286-5c6b-4e45-baaa-26564ca4b415
:ROAM_ALIASES: BGP
:END:
- Algorithm to route between [[id:c3b243ad-3fd8-4d6c-8d86-652e4bd44dce][Autonomous Systems]]
- [[file:media/bgp_1.png][Diagram]]
- Operates through Network Layer Reachability Information updates (NLRI)
** Transport Layer Protocols
:PROPERTIES:
:ID:       0110d185-9e62-4645-84cf-779dbbd87024
:END:
- UDP: unreliable
- TCP: reliable, strictly ordered
** Network Security
:PROPERTIES:
:ID:       65dfd478-db38-4a81-9ee6-6cb5e7e7bf00
:END:
- Network Attacker types:
  - Eve (eavesdropper): can see all traffic
  - Mallory: can see, edit, spoof, and drop all traffic
- Example: Exploiting [[id:2685a286-5c6b-4e45-baaa-26564ca4b415][BGP]]
  - Route hijacking
  - A gateway pretends that it can directly reach all other ASes
  - When this information is propagated, other devices routing tables will route through that gateway, thus all traffic will be sent through it
- Example: [[id:c66bc940-0321-468b-86c1-21ae30542ab4][IP]] protocol
  - Core weakness: changes made to the packet are undetectable
  - Attacks on confidentiality: packets can be sniffed
  - Attacks on integrity:
    - IP Data pollution
    - Source IP forgery
      - Used for DDoS
        - Smurf attack via ICMP protocol
        - [[file:media/smurf-attack_1.png][Diagram]]
      - Anonymous infection (e.x. Slammer Worm) is possible
        - Random source IP address means receiver cannot tell who is sending the virus
** TCP
- See [[id:458a323f-763b-458e-9ce8-7b7fb008a473][TCP]]
- Example: Predictable sequence numbers
  - [[file:media/predictable-sequence_1.png][Diagram]]
  - Open a connection as a spoofed IP address
  - Guess what sequence number was generated by the server
  - Send an ACK packet for that guessed sequence number
  - This breaks IP-based authentication which is still commonly used
** DNS
- See [[id:a3ae3cdc-5328-402e-8c47-177e942fa4fb][DNS]]
- Example: modifying in-transit DNS responses
  - Must be in between the server and the client
  - Edit the responses
- Example: DNS cache poisoning / pharming
  - DNS requests are attached to a "query ID" QID
  - In some implementations, QID is sequential / easily predictable
  - [[file:media/dns-cache-poisoning_1.png][Diagram]]
  - Results in a race between two packets
    - If you lose, correct answer will be cached
    - But eventually the correct answer is dropped from the cache and you can try again
    - Or, if you have code running on the user machine like javascript, you can manually force the cache to flush by sending requests to many different domain names
* Firewalls
:PROPERTIES:
:ID:       9eeb8562-355b-429b-9086-a374d2907f01
:END:
- See [[id:fdb9fb22-cc48-4eab-a86f-c43d83b8d827][Firewalls]]
- Operates at the border between networks
- Network level firewalls operate at the TCP/IP layer
- Application level firewalls operate on higher layers
  - Network Intrusion Detection systems (NIDS)
  - Intrusion Prevention Systems (IPS)
** Stateless Packet Filter
:PROPERTIES:
:ID:       a271bd8c-f7c8-4295-89fb-52031d751e40
:END:
- Filters based on IP and transport-level headers such as source/destination IP, protocol, ports, etc.
- [[file:media/stateless-filter_1.png][Diagram]]
- Good practice: deny by default (default deny rule)
** Stateful Packet Filters
:PROPERTIES:
:ID:       a5ab9be3-b389-4267-a333-0f1970da6621
:END:
- Works on connection-level protocols like TCP
- Maintains data about connection state and makes decisions based on it
** Proxy-based / Application Firewalls
:PROPERTIES:
:ID:       7d29626b-037c-4298-926a-f89d73199747
:END:
- Understands application logic
** Netfilter
:PROPERTIES:
:ID:       9ce420bf-8ec0-469d-82b8-e55ee167d5c5
:END:
- Linux kernel packet filtering framework
  - Prerouting
  - Postrouting
  - Forward
  - Input
  - Output
- ~iptables~ to view existing rules
** Firewall Threat Model
:PROPERTIES:
:ID:       a3b76440-040c-4869-aa0a-50da6593f00b
:END:
- Stop malicious packets from reaching the end application
- Adversary capability:
  - Adversary can send malicious/arbitrary packets
  - Firewall is between adversary and end application (i.e. adversary is outside the network boundary)
- Assumptions:
  - Firewall is working properly and is correctly configured
  - Firewall sees the same data as the application
  - Network boundary is correctly defined
- Issues:
  - Adversary is assumed to follow a specific attack pattern which can be detected by firewall
  - Firewall can inspect individual bytes but a stateless firewall can be tricked by splitting the packet
  - Encrypted (HTTPS) is hard to work with
* Secure Channel
:PROPERTIES:
:ID:       c8752aaf-6c8d-4130-8e6e-104a2897b5e3
:END:
- A secure channel preserves [[id:42696A4B-0DFA-435B-858E-D061FEB2CCA0][Confidentiality]], [[id:1FE1E862-1BEC-409A-93BB-7CBF73FACB14][Integrity]], and [[id:4ef52bfb-193b-4fee-8332-33018153a3a3][Authentication]]
- Examples
  - HTTPS
  - SSH
  - VPN
- [[file:media/secure-channel-setup_1.png][Setup]]
- How to defeat this adversary?
  - We could assume that their network is weaker than Alice and Bob's connection
  - Or we can assume that Alice and Bob have some pre-shared information that Mallory does not have
** Encryption vs Confidentiality
:PROPERTIES:
:ID:       ca28ba88-be38-4305-a048-dfaff2a40518
:END:
- Confidentiality is the goal/property, encryption is the method by which you achieve it
- [[file:media/achieve_1.png][Diagram]]
** Network Attacker
:PROPERTIES:
:ID:       fbf3ad26-d837-4f2e-b85c-1ca5b139d173
:END:
- Eve is assumed to only eavesdrop on traffic
- Mallory can modify and create traffic as well
** Symmetric Key Encryption
:PROPERTIES:
:ID:       9980e513-c6a2-49f5-befb-f129d7f3217d
:END:
- Defined by:
  - \(Setup: \rightarrow K\)
  - \(Enc: M \times K \rightarrow C\)
  - \(Dec: C \times K \rightarrow M\)
- Correctness: \(\forall m, k, Dec(Enc(m, k)) = m\)
- Security:
  - How do we mathematically define it?
  - Attacker can't guess the message, key, or ciphertext?
  - These depend on what the adversary knows beforehand
  - \(Pr[Guess = m | c] = Pr[Guess = m]\)
- Adversary knows:
  - How the Setup, Enc, Dec functions work
    - Randomness is not known
  - A distribution over M from background knowledge
    - Defender does not know this distribution
  - In addition, we may have a [[id:60ec3e66-6409-439b-98c8-eeaf7c84ea9b][Chosen Plaintext Attacker]]
*** Chosen Plaintext Attacker
:PROPERTIES:
:ID:       60ec3e66-6409-439b-98c8-eeaf7c84ea9b
:END:
- On top of base knowledge, adversary is also able to generate ciphertexts for any arbitrary m
*** One Bit Encryption
:PROPERTIES:
:ID:       91391358-9ef9-4eb2-bde3-701a0c9c0c7b
:END:
- \(m, k, c\) are all \(\{0, 1\}\)
- What function satisfies our conditions?
- Answer: XOR (or XNOR)
*** One Time Pad
:PROPERTIES:
:ID:       fe0fec92-bb87-4263-a0a8-4e2b36089b31
:END:
- \(Enc: c := m \oplus k\)
- \(Dec: m := c \oplus k\)
- Why does this work?
  - By fixing \(k\), Enc/Dec is a bijection between \(m\) and \(c\)
  - Adversary cannot distinguish \(m=0\) and \(m=1\)
- Proof
  - Let \(m \in {0, 1}\) be with \(Pr[m=0] = p\) and thus \(Pr[m=1] = (1-p)\). \(p\) can be aribtrary and chosen by the adversary.
  - \(Pr[m=0 | c=0] =  \frac{Pr[m=0 \cap c=0]}{Pr[c=0]} = \frac{p}{2} \div \frac{1}{2} = p\)
  - Likewise, for the other cases, probability is the same
- Limitations of the one time pad:
  - Large key space
    - However, note that for any cipher to satisfy perfect secrecy, \(|K| \geq |M|\)
    - Fix the key, then \(M \rightarrow C\) is a bijection for correctness
    - Then, \(|M| = |C|\)
    - Fix the message, then \(K \rightarrow C\) is a surjection
    - Then, \(|K| \geq |C|\)
  - Key cannot be reused
** Message Authentication Codes
:PROPERTIES:
:ID:       2d8a17ec-4181-4f47-9def-9dd61f2ef592
:END:
- Sender authenticity: sender can be verified to know the pre-shared key
- Message integrity: any changes to the message can be detected
- Defined by:
  - \(S(k, m)\) outputs \(t \in T\)
  - \(V(k, m, t)\) outputs 'yes' or 'no'
*** Chosen Message Attack
:PROPERTIES:
:ID:       a2e9d206-8639-4488-abb5-2fc57274569b
:END:
- Attacker can ask to generate \(t\) for any \(m\)
- Attacker must then be able to generate themselves \(t'\) for an \(m'\) which they have not seen before
*** One Bit MAC
:PROPERTIES:
:ID:       c87a0bb8-6ab4-4689-a0ab-0e12629201c2
:END:
- Tag space is \(|T| = 2^n\)
- Try \(n = 1\)
- \(S(m, k)\)?
  - \(m\)? No, we can easily forge a message
  - \(m \oplus k\)? No, we can use the message to derive \(k\)
  - Answer: \((a \cdot m + b) mod p\)
    - Note: when \(a=0, b=k, p=2\), this is the XOR function
    - \(p\) is a publically known prime
    - \((a, b)\) is the pre-shared key
    - Example: given that \((m, t) := (0, 1)\),
      - We don't know if the key is \((0, 1\) or \((1, 1)\)
      - And, those keys give different results for \(m'=1\)
      - Formally, \(Pr[S_{a,b}(m) = t \wedge S_{a,b}(m')=t'] = \frac{1}{|T|^2}\) for fixed \(m, m', t, t'\) and random across (a, b).
      - In other words, every single tag result set is equally likely
- Keys should be 2n bits for a n bit MAC, i.e. \(|K| \geq |T|^2\)
  - Proof: For any message-tag pair, how many keys give us \(S_{k}(m) = t\)? Define this set as \(K(m, t)\)
  - Claim: \(\forall(m_0, t_0), \frac{|K(m_0, t_0)|}{|K|} \leq \frac{1}{2^n}\)
  - Assume this is false, then for a random pair of chosen keys, \((m_0, t_0)\) is valid with probability \(p > \frac{1}{2^n}\)
  - We can forge a tag for \(m_1\) by randomly choosing a key in the possible key space
  - \(Pr[\text{Success}] \geq \frac{1}{|K(m_0, t_0|} = \frac{2^n}{|K|}\) since at least one of the keys is correct
  - We also want \(Pr[\text{Success}] \leq \frac{1}{2^n}\)
  - Thus \(|K| \geq 2^{2n}\)
** Computational Hardness
:PROPERTIES:
:ID:       78ba1b3d-7151-4d67-94dd-3b136e549b6c
:END:
- Perfect secrecy needs impractical key lengths
- How do we build practical cryptographic schemes?
- Assume that the adversary is limited in terms of computing power
- Thus, we build our algorithms using "hard to solve" problems
- Our symmetric encryption becomes: \(Enc(k, m) := PRG(k) \oplus m\)
  - \(PRG\) is a pseudo-random generator
- Assume: unlike the case in [[id:60ec3e66-6409-439b-98c8-eeaf7c84ea9b][Chosen Plaintext Attacker]], that the attacker has limited computational power, also known as an "efficient" attacker
  - This adversary can be modeled by an arbitrary algorithm
  - Must be polynomial in time
  - Randomized, non-deterministic execution
  - Bounds queries in a [[id:60ec3e66-6409-439b-98c8-eeaf7c84ea9b][Chosen Plaintext Attacker]] to polynomial in \(|K|\)
*** One-Way Functions
:PROPERTIES:
:ID:       dab3a043-ebff-44e0-9f82-011df3a40e64
:ROAM_ALIASES: "Practical Encryption Constructions"
:END:
- A function which is easy to compute but hard to invert
- It allows us to build Pseudorandom generators (stream cyphers), cryptographic hash functions, pseudorandom permutations (block cyphers)
*** Practical MAC Constructions
:PROPERTIES:
:ID:       22e9159e-19d6-499d-b0ba-921f982c20d4
:END:
- Cryptographic hash function: HMAC
- PRP/PRF block ciphers: OMAC, CCM, PMAC
** Asymmetric Key Cryptography
:PROPERTIES:
:ID:       b218307d-eebe-4a02-9961-447bd2a9105f
:ROAM_ALIASES: "Public-Key Cryptography"
:END:
- Two mathematically linked keys are used: a public key which is freely shared and a private key which is kept secret
- Generally, public key is used for encryption and private key is used for decryption
*** Digital Signature
:PROPERTIES:
:ID:       3c039cfb-2969-4f87-8bb8-8423e705a7ff
:END:
- Instead of encrypting with the public key, you encrypt with the private key and anyone can attempt to decrypt it
- Getting a valid output indicates that the message author knows the private key
*** Practical PKC Constructions
:PROPERTIES:
:ID:       9d04fa58-16d7-47aa-a496-5e5596952a2c
:END:
- Using [[id:78ba1b3d-7151-4d67-94dd-3b136e549b6c][Computational Hardness]]
  - Difficulty of finding large primes ([[id:036994b9-0dff-4b8e-adea-283df9012d31][RSA]])
  - Discrete Logarithm in Groups (ElGamal)
  - Problems in Lattices
    - Post-Quantum
** Key Exchange Protocol
:PROPERTIES:
:ID:       736ea3c4-b1c6-41b7-8dde-17af41ccc76a
:END:
- A way to create new shared secrets
- Forward secrecy: Even if long term shared key is compromised, sessions are still protected
*** Discrete Log
:PROPERTIES:
:ID:       dda75ccf-7cba-47ae-afd2-57a93dc2c385
:END:
- For an appropriately chosen group \(G\)
- We have a generator \(g\) such that repeatedly applying the operator to \(g\) will eventually yield all element in \(G\)
- For example, multiplication modulo some prime.
- Given \(A \in G\), it is hard to find \(a \in G\) such that \(g^a = A\)
- However, given \(a\), we can compute \(A\) in logarithmic time
*** Diffie Hellman
:PROPERTIES:
:ID:       6e6c565a-93c7-40e1-844a-53efcffa6111
:ROAM_ALIASES: CDH
:END:
- A [[id:736ea3c4-b1c6-41b7-8dde-17af41ccc76a][Key Exchange Protocol]] which employs a problem similar to [[id:dda75ccf-7cba-47ae-afd2-57a93dc2c385][Discrete Log]] as its "hard problem"
- Alice and Bob agree on a \(g\) and a \(p\)
- They pick random numbers \(a\) and \(b\).
- Alice sends \(g^a\), Bob sends \(g^b\)
- Both parties are now able to compute \(g^{ab}\), but [[id:28DAED70-FF28-43A9-AABE-A1FC13D0A639][Eve]] cannot.
  - She has to solve [[id:6e6c565a-93c7-40e1-844a-53efcffa6111][CDH]] to crack the key
- However, [[id:C6BD6271-3B92-4538-9398-FCCA53B7A1B5][Mallory]] can break this protocol
  - [[file:media/diffie-hellman-attack_1.png][Diagram]]
**** Computational Diffie Hellman
:PROPERTIES:
:ID:       3b0dbc84-5ea6-42df-8675-3703ded93bd8
:END:
- Solve the problem: given \(g, g^a, g^b\), find \(g^{ab}\)
- If [[id:dda75ccf-7cba-47ae-afd2-57a93dc2c385][Discrete Log]] is easy to solve, than [[id:3b0dbc84-5ea6-42df-8675-3703ded93bd8][Computational Diffie Hellman]] is easy to solve.
- So, if [[id:3b0dbc84-5ea6-42df-8675-3703ded93bd8][Computational Diffie Hellman]] is hard, then [[id:dda75ccf-7cba-47ae-afd2-57a93dc2c385][Discrete Log]] is hard.
*** Station-to-Station
:PROPERTIES:
:ID:       28f0be11-63e0-4fe5-8ef2-47ff6ccbcc02
:END:
- Fix [[id:6e6c565a-93c7-40e1-844a-53efcffa6111][Diffie Hellman]] by adding [[id:3c039cfb-2969-4f87-8bb8-8423e705a7ff][Digital Signature]]
- Requires pre shared keys
- [[file:media/station-to-station_1.png][Diagram]]
** HTTPS
:PROPERTIES:
:ID:       406b5c5c-ab3a-499a-b830-60dc4e516894
:END:
- HTTP + SSL/TLS
- High level steps:
  - Negotiate to figure out which cipher suites should be used
  - Run an authenticated key exchange like [[id:28f0be11-63e0-4fe5-8ef2-47ff6ccbcc02][Station-to-Station]]
  - You end up with a shared secret key
  - The rest of the communication is secured using that key
    - Symmetric cryptography is faster and smaller to run
  - Renegotiation is possible (although depreciated)
- But how do we know what public key to use for authenticated key exchange?
  - The other party sends it to you, but how do you know it's legitimate?
  - Certificate signing can allow you to trace a legitimate public key to be "trusted" by some root CA
  - Root CA signs a certificate allowing an entity to sign a limited set of domains like *.google.com
  - That intermediate CA may then sign a certificate for the actual endpoint like mail.google.com
- [[file:media/tls_1.png][TLS Diagram 1]]
- [[file:media/tls_2.png][TLS Diagram 2]]
- Alternative using [[id:6e6c565a-93c7-40e1-844a-53efcffa6111][Diffie Hellman]]:
- [[file:media/tls-dhe_1.png][TLS with DHE]]
*** Arguments for HTTPS
:PROPERTIES:
:ID:       7e7a74a9-6a04-411d-a4b9-427159892175
:END:
- State threat model: what are your assumptions?
  - User is using a secure channel
  - Crypto primitives are secure
  - TLS protocol design is secure
  - TLS protocol implementation is secure
  - Certificate issuers are uncompromised
  - Users check browser UI correctly
  - (from me) Browser UI displays information correctly
  - Alice & Bob's secrets are secure
  - Entities are authenticated correctly
