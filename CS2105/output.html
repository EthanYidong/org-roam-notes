<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Notes</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.css" integrity="sha384-bYdxxUwYipFNohQlHt0bjN/LCpueqWz13HufFEV1SUatKs1cm4L6fFgCi1jT643X" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.js" integrity="sha384-Qsn9KnoKISj6dI8g7p1HBlNpVx0I8p1SvlwOldgi3IorMle61nQy4zEahWYtljaz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>
    
    <link rel="stylesheet" type="text/css" href="https://gongzhitaao.org/orgcss/org.css"/>
</head>
<body>
  <main><section><p>:ID:       D1F12114-39AC-40DC-98D0-7B6F67DEC041</p><ul><li><p>links :: <a href="id:192A0605-67DE-4277-9FEF-5C16C81937F8">CS2105</a></p></li></ul></section><h1>Internet</h1><section><ul><li><p>Internet is made up of routers</p><ul><li><p>Data packets are sent through the network from source to destination</p></li></ul></li></ul></section><h1>Data Transmission</h1><section><ul><li><p>Packet switching</p><ul><li><p>Users under the same router share its resources</p></li><li><p>Resources are not reserved, used on demand</p><ul><li><p>A result of this is that packets may take different paths</p></li><li><p>Congestion is possible</p></li></ul></li><li><p>Bits sent over a link which represent packets</p><ul><li><p>Timing is a product of maximum bandwidth and propagation delay</p></li></ul></li><li><p>Routers implement store and forward</p><ul><li><p>Entire packet must reach the router before it will forward to the next stop in the network</p></li><li><p>This adds additional delay to the transmission</p></li><li><p>This is for the purpose for:</p><ul><li><p>Integrity Checks</p></li></ul></li></ul></li></ul></li></ul></section><h1>Network Conditions</h1><section><ul><li><p>links :: <a href="id:1F24CF84-A241-4317-AC6D-C4C4683F34DF">CS2105 Exams</a></p></li></ul></section><h2>Packet Loss</h2><section><ul><li><p>Packet loss may occur when the router&apos;s buffer is full</p></li><li><p>Connectivity issues may occur (both wired and wireless)</p></li><li><p>Signal noise may result in corrupted packets</p></li></ul></section><h2>Packet Delay</h2><h3>Processing Delay</h3><section><ul><li><p>Generally ignored</p></li><li><p>How long it takes to process the packet (check for integrity, determine what to do with the packet)</p></li></ul></section><h3>Queueing Delay</h3><section><ul><li><p>Generally ignored</p></li><li><p>Time taken waiting for the router to finish processing packets that arrived before</p></li></ul></section><h3>Transmission Delay</h3><section><ul><li><p>Limited by bandwidth of the connection</p></li><li><p>&quot;How long do I have to wait before can I send the next bit?&quot;</p></li><li><p>\(\frac{\text{bits per time}}{\text{number of bits}}\)</p></li></ul></section><h3>Propagation Delay</h3><section><ul><li><p>Limited by the speed of the signal along the connection.</p></li><li><p>&quot;How long does it take for the data to go from point A to point B&quot;?</p></li><li><p>\(\frac{\text{length of connection}}{\text{speed of data through connection}}\)</p></li></ul></section><h1>Network Protocols</h1><section><ul><li><p>The <a href="id:3E696C35-46F4-4C10-98C9-584A8D60616C">Internet</a> supports many various kinds of network applications</p><ul><li><p>The Web, VoIP, email, games, etc.</p></li></ul></li></ul></section><h1>Transport Services</h1><section><ul><li><p>Closely tied to the <a href="id:dff0f2f7-2b30-48bd-8fb5-220db2076834">Transport Layer</a></p></li><li><p>Needs:</p><ul><li><p>Data Integrity</p><ul><li><p>&quot;Is the data correct?&quot;</p></li></ul></li><li><p>Timing</p><ul><li><p>&quot;Is the data recent?&quot;</p></li></ul></li><li><p>Throughput</p><ul><li><p>&quot;Is the data fast?&quot;</p></li></ul></li><li><p>Security</p></li></ul></li></ul></section><h1>OSI Layers</h1><section><ul><li><p>The OSI Layer Model is a structure that can be used to describe the way data is transmitted and used by computers</p></li></ul></section><h2>Packet Layer</h2><section><ul><li><p>1st layer of the <a href="id:e0360e0e-695b-4db0-8bda-f1ab12bd6019">OSI Layers</a></p></li></ul></section><h2>Data Link Layer</h2><section><ul><li><p>2nd layer of the <a href="id:e0360e0e-695b-4db0-8bda-f1ab12bd6019">OSI Layers</a></p></li></ul></section><h2>Network Layer</h2><section><ul><li><p>3rd layer of the <a href="id:e0360e0e-695b-4db0-8bda-f1ab12bd6019">OSI Layers</a></p></li><li><p>Delivers packets from sender to receiver hosts</p></li></ul></section><h2>Transport Layer</h2><section><ul><li><p>4th layer of the <a href="id:e0360e0e-695b-4db0-8bda-f1ab12bd6019">OSI Layers</a></p></li><li><p>Runs in hosts:</p><ul><li><p>Sender side:</p><ul><li><p>Break message into segments and pass to the <a href="id:5d0b0590-fd98-4db1-89f1-f8f38bd11bb7">Network Layer</a></p></li></ul></li><li><p>Receiver side:</p><ul><li><p>Reassembles segments into message and pass to the <a href="id:89296f19-c817-43a7-8ef6-013e697d32ab">Application Layer</a></p></li></ul></li><li><p>In between:</p><ul><li><p>Check destination IP to decide routing</p></li></ul></li></ul></li></ul></section><h2>Session Layer</h2><section><ul><li><p>5th layer of the <a href="id:e0360e0e-695b-4db0-8bda-f1ab12bd6019">OSI Layers</a></p></li><li><p>Grouped under the <a href="id:89296f19-c817-43a7-8ef6-013e697d32ab">Application Layer</a> for <a href="id:192A0605-67DE-4277-9FEF-5C16C81937F8">CS2105</a></p></li></ul></section><h2>Presentation Layer</h2><section><ul><li><p>6th layer of the <a href="id:e0360e0e-695b-4db0-8bda-f1ab12bd6019">OSI Layers</a></p></li><li><p>Grouped under the <a href="id:89296f19-c817-43a7-8ef6-013e697d32ab">Application Layer</a> for <a href="id:192A0605-67DE-4277-9FEF-5C16C81937F8">CS2105</a></p></li></ul></section><h2>Application Layer</h2><section><ul><li><p>7th layer of the <a href="id:e0360e0e-695b-4db0-8bda-f1ab12bd6019">OSI Layers</a></p></li></ul></section><h1>The Web</h1><section><ul><li><p>An application of the <a href="id:3E696C35-46F4-4C10-98C9-584A8D60616C">Internet</a></p></li></ul></section><h1>TCP</h1><section><ul><li><p><a href="id:dff0f2f7-2b30-48bd-8fb5-220db2076834">Transport Layer</a> protocol</p></li><li><p>Well ordered</p></li><li><p><img src="media/transport-diagram-tcp_1.png" style="max-width: 500px; min-width: 200px"></img></p></li><li><p>Properties:</p><ul><li><p>Point-to-Point: one sender, one receiver</p></li><li><p>Connection-oriented: requires handshake before sending of data</p></li><li><p>Full duplex: bidirectional sending of data</p></li><li><p>Reliable: guaranteed to get an in-order, correct reassembly of the sent data</p></li></ul></li><li><p>Connection is defined by src IP, src port, dest IP, dest port</p></li><li><p>TCP will break the message into packets. The maximum segement size (MSS) is typically 1460 bytes, with a 20 byte header</p></li><li><p>Header contains:</p><ul><li><p><img src="media/tcp-header_1.png" style="max-width: 500px; min-width: 200px"></img></p></li></ul></li><li><p>Sequence #</p><ul><li><p>First one is randomly chosen</p></li><li><p>Randomized to provide some distinctions between repeat connections</p></li><li><p>Subsequent ones are equal to the first one plus the byte number of the first byte of the data in sequence.</p></li></ul></li><li><p>Ack #</p><ul><li><p>Equal to the sequence number of the first byte in sequence not received as part of the stream</p></li></ul></li><li><p><img src="media/tcp-seq-ack_1.png" style="max-width: 500px; min-width: 200px"></img></p></li><li><p>TCP does not specify how the receiver should handle out-of-order packets</p></li><li><p><img src="media/tcp-diagram_2.png" style="max-width: 500px; min-width: 200px"></img></p></li><li><p><img src="media/tcp-diagram_3.png" style="max-width: 500px; min-width: 200px"></img></p><ul><li><p>? = 105, because byte 105 is the first byte not received</p></li></ul></li><li><p>Timeout</p><ul><li><p>Timeout must be set based on the connection state</p></li><li><p>It is dynamically calculated based on the connection speed</p></li><li><p><img src="media/tcp-timeout_1.png" style="max-width: 500px; min-width: 200px"></img></p></li></ul></li><li><p>Because the timeout may be long, TCP also has a mechanism to resend packets assumed to be lost, known as fast resend</p><ul><li><p>If 4 identical ACKs, then TCP will assume the packet after the acked packet was lost</p></li></ul></li><li><p><img src="media/tcp-fast-resend_1.png" style="max-width: 500px; min-width: 200px"></img></p></li><li><p>Establishing the connection: handshake</p><ul><li><p><img src="media/tcp-connect_1.png" style="max-width: 500px; min-width: 200px"></img></p></li></ul></li><li><p>Closing the connection:</p><ul><li><p><img src="media/tcp-close_1.png" style="max-width: 500px; min-width: 200px"></img></p></li></ul></li></ul></section><h1>UDP</h1><section><ul><li><p><a href="id:dff0f2f7-2b30-48bd-8fb5-220db2076834">Transport Layer</a> protocol</p></li><li><p>No ordering</p></li><li><p>Adds very little to <a href="id:c66bc940-0321-468b-86c1-21ae30542ab4">IP</a></p><ul><li><p>Multiplexing data on the sender into many packets</p></li><li><p>Demultiplexing packets on the receiver into the original data</p></li><li><p>Checksum</p></li></ul></li><li><p>When a UDP receiver receives a UDP segment,</p><ol><li><p>It checks the destination port from the segment</p></li><li><p>The UDP segment is sent to the socket for that port</p></li><li><p>IP Datagrams (with possibly different sources) with the same port are directed to the same UDP port</p></li></ol></li><li><p><img src="media/transport-diagram-udp_1.png" style="max-width: 500px; min-width: 200px"></img></p></li><li><p>Checksum calculation:</p><ul><li><p>Treat the segment as a sequence of 16-bit integers</p></li><li><p>Add all 16-bit integers in the sequence together</p></li><li><p>Any carries are also added to the checksum in the lowest significant bit</p></li><li><p>Get the 1s complement to find the checksum</p><ul><li><p>This is just flipping all the bits</p></li></ul></li></ul></li></ul></section><h1>Round Trip Timing</h1><section><ul><li><p>The amount of time taken for a packet to be sent from client to server and for a reply to be received.</p></li></ul></section><h1>HTTP</h1><section><ul><li><p>The <a href="id:89296f19-c817-43a7-8ef6-013e697d32ab">Application Layer</a> protocol for <a href="id:d81d3738-a08e-498a-ae6b-1118a0341de1">The Web</a></p></li><li><p>Uses <a href="id:458a323f-763b-458e-9ce8-7b7fb008a473">TCP</a> as the <a href="id:dff0f2f7-2b30-48bd-8fb5-220db2076834">Transport Layer</a></p></li></ul></section><h2>HTTP 1.0</h2><section><ul><li><p>links :: <a href="id:1F24CF84-A241-4317-AC6D-C4C4683F34DF">CS2105 Exams</a></p></li><li><p>Non-persistant HTTP connection</p><ul><li><p>Each object needs 2 <a href="id:be2e19da-7142-44a9-8707-6e6f3412d46f">RTTs</a></p></li><li><p>Time taken to send data is based on <a href="id:86A82389-CC39-4780-8D82-E05918A03EFF">Packet Delay</a></p></li><li><p>Timing of message = \(2 \times \text{RTT} + \text{HTTP Header Time} + \text{Data Time}\)</p></li><li><p>Note that speed is often given in bits per second, while size is given in bytes.</p></li></ul></li></ul></section><h2>HTTP 1.1</h2><section><ul><li><p>links :: <a href="id:1F24CF84-A241-4317-AC6D-C4C4683F34DF">CS2105 Exams</a></p></li><li><p>Persistant HTTP connection</p><ul><li><p>The TCP connection is opened once across all objects (1 <a href="id:be2e19da-7142-44a9-8707-6e6f3412d46f">RTT</a>)</p></li><li><p>Multiple objects can be grouped together with one request, so each group also requires one request (1 <a href="id:be2e19da-7142-44a9-8707-6e6f3412d46f">RTT</a>)</p><ul><li><p>This occurs when the client knows that it needs multiple resources to be fetched.</p></li></ul></li><li><p>If there is time where the computer does not know what it needs to be fetching, it will need to idle until it knows.</p></li><li><p>Time taken to send data is based on <a href="id:86A82389-CC39-4780-8D82-E05918A03EFF">Packet Delay</a></p></li><li><p>Timing across all messages = \(\text{RTT} \times (\text{Number of Objects} + 1) + \text{Data Time} + \text{Idle Time}\)</p></li><li><p>Note that the speed is often given in bits per second, while size is given in bytes.</p></li></ul></li></ul></section><h1>IP</h1><section><ul><li><p><a href="id:5d0b0590-fd98-4db1-89f1-f8f38bd11bb7">Network Layer</a> service of the internet</p></li><li><p>Runs within routers between the sender and receiver hosts</p><ul><li><p>Routers will read the IP header to determine where to send the packet</p></li></ul></li><li><p>IP header, which is added on to every datagram, is 20 bytes for IPV4</p><ul><li><p><img src="media/ip-header_1.png" style="max-width: 500px; min-width: 200px"></img></p></li></ul></li><li><p>IPV6:</p><ul><li><p><img src="media/ipv6-header_1.png" style="max-width: 500px; min-width: 200px"></img></p></li></ul></li></ul></section><h2>Fragmentation</h2><section><ul><li><p>Different network have a different Max Transfer Unit, the maximum amount of data a <a href="id:491f607a-a390-4694-8544-1fce9a3a7d86">Data Link Layer</a>-level frame can carry</p></li><li><p>IP datagrams that are too large may be fragmented by routers</p></li><li><p>Destination will reassemble the packet</p></li><li><p>Note that this occurs independantly of the transport layer protocols; the network layer has no knowledge of the structure of TCP or UDP.</p></li><li><p><img src="media/fragment_1.png" style="max-width: 500px; min-width: 200px"></img></p></li></ul></section><h1><a href="id:c66bc940-0321-468b-86c1-21ae30542ab4">IP</a> Address</h1><section><ul><li><p>32 bit(IPv4) or 128 bit(IPv6) that identifies a node in a network</p><ul><li><p>Both Hosts and Routers</p></li></ul></li><li><p>IPv4 addresses look like [0-255].[0-255].[0-255].[0-255]</p></li><li><p>IPv4 blocks look like [0-255].[0-255].[0-255].[0-255]/N</p><ul><li><p>N denotes the number of constant bits at the front</p></li><li><p>IP addresses can be split into two parts, the subnet prefix and the hosst ID</p></li></ul></li><li><p>IP addresses are associated with a <a href="id:16c49997-a487-4021-b7d1-a91b09859d1d">Network Interface</a></p></li></ul></section><h2>Special IP Addresses</h2><section><ul><li><p>0.0.0.0: Non-routable meta-address, special use</p></li><li><p>127.0.0.0/8: Loopback address, sends to the host</p><ul><li><p>Originally 127.0.0.1/32</p></li></ul></li><li><p>Private addresses</p><ul><li><p>10.0.0.0/8</p></li><li><p>172.16.0.0/12</p></li><li><p>192.168.0.0/16</p></li></ul></li><li><p>255.255.255.255/32</p><ul><li><p>Broadcast address, which will send a message to all hosts on that subnet</p></li></ul></li></ul></section><h2>IP Address Allocation</h2><section><ul><li><p>Organizations will buy IP addresses from a registry or rent from their ISP</p></li><li><p>ISPs get their blocks from ICANN</p></li></ul></section><h1>Domain Name System</h1><section><ul><li><p>Two ways to identify a host:</p><ul><li><p>Hostname: www.example.org</p></li><li><p><a href="id:11fd492e-05ef-4acd-818c-60fdcc28ae46">IP Address</a>: 93.184.216.34</p></li></ul></li><li><p>Hostnames are easier to remember, but computers can only use IP addresses to communicate</p></li><li><p>DNS is an <a href="id:89296f19-c817-43a7-8ef6-013e697d32ab">Application Layer</a> protocol which allows computers to find the IP address associated with a host name</p></li><li><p>These calls are made by browser when attempting to visit a <a href="id:d81d3738-a08e-498a-ae6b-1118a0341de1">Website</a></p></li><li><p>Can lookup using nslookup or dig</p><ul><li><p>nslookup &lt;domain&gt;</p></li><li><p>dig &lt;type?&gt; &lt;domain&gt; &lt;&quot;+short&quot;?&gt;</p></li></ul></li><li><p>DNS uses <a href="id:be4e6279-b595-4fcf-befc-06d57273d988">UDP</a> for speed</p><ul><li><p>UDP is unreliabale but DNS does not need reliability</p></li><li><p>Locally served DNS has lower chance of packet loss</p></li><li><p>Browsers can send multiple identical DNS requests</p></li></ul></li></ul></section><h2>DNS Servers</h2><section><ul><li><p>DNS servers exist in a hierarchy</p><ul><li><p>Root server on top</p></li><li><p>TLD servers next</p></li><li><p>Then authoritative domain servers</p></li><li><p>...</p></li></ul></li></ul></section><h2>Local <a href="id:021e6dab-9bc6-4432-bddb-6010e378a3bd">DNS Servers</a></h2><section><ul><li><p>A DNS Server hosted within a LAN, such as your workplace, your ISP, your school, your house</p></li><li><p>The Local DNS Server is &quot;Non-authoritative&quot;</p></li><li><p>Querys and records are <a href="id:7a342c16-c2cd-4098-9326-17e0e9654c0b">Cached</a> locally to speed up request fufillment</p></li></ul></section><h2>DNS Cacheing</h2><section><ul><li><p>Records are saved locally as a cache to speed up repeated <a href="id:a3ae3cdc-5328-402e-8c47-177e942fa4fb">DNS</a> requests</p></li><li><p>Life is based on the TTL property of a DNS record</p></li></ul></section><h2>Resource Records</h2><section><ul><li><p>Format of DNS records</p></li><li><p>Maps between host and IP address</p></li><li><p>(name, value, type, ttl)</p><ul><li><p>Name is the hostname, i.e. www.example.com</p></li><li><p>Value is the value mapped to the hostname, i.e. 93.184.216.34</p></li><li><p><a href="id:1cb6721f-2c5a-40a0-a447-58e3bc3aea04">Type</a>: the type of entry</p></li><li><p>TTL: Time to Live (<a href="id:7a342c16-c2cd-4098-9326-17e0e9654c0b">DNS Cache</a> life)</p></li></ul></li></ul></section><h2>Record Types</h2><h3>A</h3><section><ul><li><p>&quot;Alias&quot;</p></li><li><p>Name is the hostname</p></li><li><p>Value is the ip address the name maps to</p></li></ul></section><h3>CNAME</h3><section><ul><li><p>&quot;Canonical name&quot;</p></li><li><p>Name is the alias name</p></li><li><p>Value is the canonical location that the alias name maps to</p></li><li><p>Essentially operates like <a href="id:93b7ce91-aa85-4195-a528-c342661a9aa3">A</a> but value is a hostname</p></li></ul></section><h3>NS</h3><section><ul><li><p>&quot;Name Server&quot;</p></li><li><p>Name is the domain</p></li><li><p>Value is the name server</p></li><li><p>The name server provides the hostname of the canonical nameserver which is in charge of providing values to the <a href="id:a3ae3cdc-5328-402e-8c47-177e942fa4fb">DNS</a></p></li></ul></section><h3>MX</h3><section><ul><li><p>&quot;Mail Exchanger&quot;</p></li><li><p>Name is the domain</p></li><li><p>Value is the mail server</p></li></ul></section><h1>Addressing</h1><section><ul><li><p><a href="id:11fd492e-05ef-4acd-818c-60fdcc28ae46">IP Addresses</a> are used to identify hosts</p></li><li><p>This is not however, because many different applications might be running on the host</p></li><li><p>Applications are identified by using a port number (16 bits)</p><ul><li><p>Ports 1-1023 are reserved</p></li></ul></li><li><p>Example Ports:</p><ul><li><p>80: HTTP server</p></li><li><p>25: SMTP server</p></li></ul></li></ul></section><h1>Socket</h1><section><ul><li><p>Sockets are an interface that sit between the <a href="id:89296f19-c817-43a7-8ef6-013e697d32ab">Application Layer</a> and <a href="id:dff0f2f7-2b30-48bd-8fb5-220db2076834">Transport Layer</a></p></li><li><p>Applications treat the internet like a black box, and communicate only using the socket</p></li><li><p><a href="id:be4e6279-b595-4fcf-befc-06d57273d988">UDP</a>:</p><ul><li><p>Socket has no connection, packets are all sent as they are to the server and port</p></li><li><p><img src="media/udp-diagram_1.png" style="max-width: 500px; min-width: 200px"></img></p></li></ul></li><li><p><a href="id:458a323f-763b-458e-9ce8-7b7fb008a473">TCP</a>:</p><ul><li><p>A connection must first be established</p></li><li><p>Server creates a socket for each client</p></li><li><p><img src="media/tcp-diagram_1.png" style="max-width: 500px; min-width: 200px"></img></p></li><li><p>Note: In the <a href="id:1F24CF84-A241-4317-AC6D-C4C4683F34DF">Exam</a>, make sure to count a +1 for the welcome socket</p></li></ul></li></ul></section><h1>Bytes vs Bits</h1><section><ul><li><p>If the b is lowercase (b, Kb, Mb, ...), then it refers to bits</p></li><li><p>If the B is uppercase (B, KB, MB), then it refers to bytes</p></li></ul></section><h1>Topology</h1><section><ul><li><p>Minimal:</p><ul><li><p>Tree topology</p><ul><li><p>Organized in a tree</p></li></ul></li><li><p>Chain topology</p><ul><li><p>Special case of tree topology where every node has at most one child</p></li></ul></li><li><p>Star topology</p><ul><li><p>Special case of tree topology where one node has all the children</p></li></ul></li></ul></li><li><p>Maximal:</p><ul><li><p>Mesh</p><ul><li><p>Fully connected</p></li></ul></li></ul></li></ul></section><h1>Reliable Data Transfer</h1><section><ul><li><p>&quot;Sending data reliably over the internet is hard&quot;</p></li><li><p>Question: how do we build a reliable <a href="id:dff0f2f7-2b30-48bd-8fb5-220db2076834">Transport Layer</a> protocol on top of an unreliable <a href="id:5d0b0590-fd98-4db1-89f1-f8f38bd11bb7">Network Layer</a>?</p></li><li><p>The network may:</p><ul><li><p>Corrupt packets</p></li><li><p>Drop packets</p></li><li><p>Reorder packets</p></li><li><p>Deliver packets after an arbitrary delay</p></li></ul></li><li><p>Our reliable transport service should:</p><ul><li><p>Guarantee packet delivery and correctness</p></li><li><p>Deliver packets in the same order that they are sent</p></li></ul></li><li><p><img src="media/rdt-protocol_1.png" style="max-width: 500px; min-width: 200px"></img></p></li></ul></section><h1>Toy <a href="id:074a6a63-d7ce-4112-972f-58fa072d2a0e">RDTs</a></h1><section><ul><li><p><img src="media/toy-rdt_1.png" style="max-width: 500px; min-width: 200px"></img></p></li></ul></section><h2>Toy RDT 1.0</h2><section><ul><li><p>Assume that the channel is 100% reliable</p></li><li><p>We just have to simply send the packets as is</p></li><li><p>We get this <a href="id:6ec79c40-1a4a-4f24-b947-dc6cb3611532">FSM</a>:</p></li><li><p><img src="media/toy-rdt-1.0_1.png" style="max-width: 500px; min-width: 200px"></img></p></li></ul></section><h2>Toy RDT 2.0</h2><section><ul><li><p>Assume that the channel may flip bits</p></li><li><p>Other than that, the channel is 100% reliable</p></li><li><p>We can detect errors with a checksum</p></li><li><p>Use ACK (acknowledge) and NAK (negative acknowledge) on the receiver side to tell the sender whether or not the packet was ok</p></li><li><p>This is a <a href="id:f4930941-2e92-4fff-a7b3-4ee7f8583e60">Send-and-Wait Protocol</a></p></li><li><p><img src="media/toy-rdt-2.0_1.png" style="max-width: 500px; min-width: 200px"></img></p></li><li><p>We get this <a href="id:6ec79c40-1a4a-4f24-b947-dc6cb3611532">FSM</a>:</p></li><li><p><img src="media/toy-rdt-2.0_2.png" style="max-width: 500px; min-width: 200px"></img></p></li><li><p>Flaw: what happens when the ACK or NAK is corrupted?</p><ul><li><p>Can the sender just resend the packet if it receives garbled feedback?</p></li></ul></li></ul></section><h2>Toy RDT 2.1 (2.0 w/ Packet Sequence #)</h2><section><ul><li><p>Include the sequence number to each packet</p></li><li><p>Receiver can discard packets that have already been received</p></li><li><p><img src="media/toy-rdt-2.1_1.png" style="max-width: 500px; min-width: 200px"></img></p></li><li><p><img src="media/toy-rdt-2.1_2.png" style="max-width: 500px; min-width: 200px"></img></p></li><li><p>We get this <a href="id:6ec79c40-1a4a-4f24-b947-dc6cb3611532">FSM</a>:</p></li><li><p><img src="media/toy-rdt-2.1_3.png" style="max-width: 500px; min-width: 200px"></img></p></li><li><p><img src="media/toy-rdt-2.1_4.png" style="max-width: 500px; min-width: 200px"></img></p></li></ul></section><h2>Toy RDT 2.2 (2.1 w/out NAK)</h2><section><ul><li><p>Instead of sending NAK for corrupted packets, instead send ACK for the previous correct packet</p></li><li><p><img src="media/toy-rdt-2.2_1.png" style="max-width: 500px; min-width: 200px"></img></p></li></ul></section><h2>Toy RDT 3.0</h2><section><ul><li><p>Assume that the channel may flip bits, lose packets, and may have arbitrarily long delay</p></li><li><p>Will not reorder packets</p></li><li><p>How do we detect packet loss, since the delay can be arbitrary?</p></li><li><p>Set a reasonable timeout value to trigger an assumption that the packet is lost, so the sender will resend if an ACK is not received in time</p></li><li><p>If the packet is delayed and timeout is triggered, this means that a duplicate will have been sent.</p></li><li><p><img src="media/toy-rdt-3.0_1.png" style="max-width: 500px; min-width: 200px"></img></p></li><li><p><img src="media/toy-rdt-3.0_2.png" style="max-width: 500px; min-width: 200px"></img></p></li><li><p>We get this <a href="id:6ec79c40-1a4a-4f24-b947-dc6cb3611532">FSM</a>:</p></li><li><p><img src="media/toy-rdt-3.0_3.png" style="max-width: 500px; min-width: 200px"></img></p></li><li><p>Receiver is about the same as Toy RDT 2.1</p></li></ul></section><h1>Finite State Machines</h1><section><ul><li><p>A finite state machine is defined by a finite set of states and a set of transitions between states</p></li><li><p><img src="media/example-fsm_1.png" style="max-width: 500px; min-width: 200px"></img></p></li></ul></section><h1>Send-and-Wait Protocol</h1><section><ul><li><p>This is a protocol which requires senders to wait for a response after each packet is sent.</p></li></ul></section><h1>Pipelining Protocol</h1><section><ul><li><p>A protocol which allows senders to send multiple un-acknowledged responses at once</p></li></ul></section><h2>Go-Back-N</h2><section><ul><li><p><img src="media/go-back-N_1.png" style="max-width: 500px; min-width: 200px"></img></p></li><li><p>Send multiple packets at once</p></li><li><p>Receiving out-of-order or invalid packets will cause the receiver to re-acknowledge the last well-ordered packet</p></li><li><p>Receiving repeat acknowledgements will be ignored, then the sender will calculate the last acknowledged packet</p></li><li><p>Uses a window size &quot;N&quot; which indicates the maximum number of unacknowledged packets to be sent</p></li></ul></section><h2>Selective Repeat</h2><section><ul><li><p><img src="media/selective-repeat_1.png" style="max-width: 500px; min-width: 200px"></img></p></li><li><p><img src="media/selective-repeat_2.png" style="max-width: 500px; min-width: 200px"></img></p></li><li><p>Send multiple packets at once</p></li><li><p>All valid received packets will be acknowledged</p></li><li><p>Sender keeps a timer for all unacknowledged packets</p></li><li><p>Resend unacked packets on timeout</p></li><li><p>More efficient than <a href="id:362bcf01-6358-4517-850d-7976dc2b089e">Go-Back-N</a>, but more complicated, as everything may be out of order</p></li><li><p>Also keeps a window size, and the window is guaranteed to contain all unacked packets</p></li></ul></section><h1>Speed of <a href="id:f4930941-2e92-4fff-a7b3-4ee7f8583e60">Send-and-Wait Protocol</a> and <a href="id:a63ee94c-54af-43e8-acd7-199f0577f6d5">Pipelining Protocol</a></h1><section><ul><li><p>Send and wait implementations such as <a href="id:7a3e843b-8568-45e8-9af3-9d963ba4b722">Toy RDT 3.0</a> are generally very slow because the sender must wait for a reply every time it wants to send a packet, leading to a vast underutilization of the bandwidth</p></li><li><p>Pipelining: send multiple un-acknowledged packets at once</p></li><li><p>Sending 3 packets at once multiplies the utilization by 3</p></li></ul></section><h1>DHCP</h1><section><ul><li><p>A protocol which allows hosts to dynamically obtain an <a href="id:11fd492e-05ef-4acd-818c-60fdcc28ae46">IP Address</a> when it joins a network</p></li><li><p>Renewable</p></li><li><p>Allows reuse of address (hosts can only hold an address while connected)</p></li><li><p>4 steps:</p><ol><li><p>Host broadcasts DHCP discover</p></li><li><p>DHCP server responds with a DHCP offer message</p></li><li><p>Host requests an IP address with a DHCP request messages</p></li><li><p>DHCP server will respond with a DHCP ack</p></li></ol></li><li><p>Note that the apparent &quot;redundancy&quot; occurs because there may be multiple DHCP servers in a network</p></li><li><p>DHCP may also provide the router IP, local <a href="id:a3ae3cdc-5328-402e-8c47-177e942fa4fb">DNS</a> IP, as well as the <a href="id:355ba6f2-81ee-4124-9d6a-29c26024ccb8">Subnet Mask</a></p></li><li><p><img src="media/dhcp_1.png" style="max-width: 500px; min-width: 200px"></img></p></li></ul></section><h1>Network Mask</h1><section><ul><li><p>INdicates the network prefix vs host ID of an IP address</p></li></ul></section><h1>Network Interface</h1><section><ul><li><p>An interface which enables a computer to connect to a network</p></li><li><p>For example</p><ul><li><p>WiFi</p></li><li><p>Ethernet</p></li></ul></li><li><p>A host will usually have one or two, and a router may have many</p></li></ul></section><h1>Subnet</h1><section><ul><li><p>A network formed by directly connected computers</p></li><li><p>Subnets are assigned a IP address prefix</p></li></ul></section><h2>Subnet Mask</h2><section><ul><li><p>Set all the subnet prefix bits to 1, and all the host ID bits to 0</p></li><li><p>For the IP Address 192.168.1.0/24: 255.255.255.0</p></li></ul></section><h1>Classless Inter-domain Routing</h1><section><ul><li><p>AKA CIDR</p></li><li><p>The method of assigning IP addresses with a subnet prefix and a host ID</p></li></ul></section><h1><a href="id:11fd492e-05ef-4acd-818c-60fdcc28ae46">IP Address</a> Prefix Matching</h1><section><ul><li><p>Routers can request for all packets with a prefix to be routed to them after <a href="id:160b1d3b-04d0-4162-b7be-501077aacb5b">IP Address Allocation</a></p></li><li><p>This is done based on the longest matching prefix, so if someone requests for 192.0.0.0/8, and someone else requests for 192.168.0.0/16, then packets with IP 192.168.1.1 will get routed to the second.</p></li></ul></section><h1>Routing</h1><h2>Intra-AS routing</h2><section><ul><li><p>Routes between nodes which are part of the same <a href="id:c3b243ad-3fd8-4d6c-8d86-652e4bd44dce">AS</a></p></li><li><p>If each link has a cost associated with it, the problem of intra-AS routing becomes a min cost path problem</p><ul><li><p>Cost generally inversely related to bandwidth, or could be just constant</p></li></ul></li></ul></section><h3>Link State</h3><section><ul><li><p>Each router periodically shares link cost values with the whole network</p></li><li><p>All routers have complete knowledge of all costs in the network</p></li><li><p>Uses dijkstra&apos;s algorithm to compute the best path for a packet</p></li></ul></section><h3>Distance Vector</h3><section><ul><li><p>Router knows physically connected neighbors and will share link costs to them</p></li><li><p>Routers will exchange &quot;local views&quot; with its neighbors and update its own local view based on its neighbors &quot;local views&quot;</p><ul><li><p>The local view is a set of currently known shortest distances from all routers to all other routers.</p></li><li><p>Local views will be updated using the <a href="id:68aa9ceb-91e4-43be-adaf-1e0f98fe96d3">Bellman-Ford Equation</a></p></li><li><p><img src="media/local-view_1.png" style="max-width: 500px; min-width: 200px"></img></p></li></ul></li></ul></section><h3>Routing Information Protocol</h3><section><ul><li><p>AKA RIP</p></li><li><p>A <a href="id:4573522c-2b99-4582-b67b-69af2dae2e6b">Intra-AS routing</a> protocol which implements the <a href="id:7caaf9c5-3359-4900-bc29-f636eefb87ef">Distance Vector</a> algorithm.</p></li><li><p>Uses hop count as the cost metric (i.e. each link has cost 1), which means that it ignores network congestion</p></li><li><p>Routing table is sent every 30 seconds over UDP port 520</p></li><li><p>&quot;Self-repair&quot;, meaning that if no updates have been received from a neighbor after 3 minutes, that neighbor is assumed to be failed and removed</p></li></ul></section><h1>Autonomous System</h1><section><ul><li><p>An ISP / other organization which owns its routers and links</p></li><li><p>Has a clearly defined routing policy which is applied to the whole network</p></li></ul></section><h1>Bellman-Ford Equation</h1><section><ul><li><p>\(d_x(y)=min_v\{c(x,v)+d_v(y)\}\) across all neighbors v of x</p><ul><li><p>Where \(d_x(y)\) is the minimum distance from x to y</p></li><li><p>and \(c(x,v)\) is the cost of the link between x and v</p></li></ul></li></ul></section><h1>Network Address Translation</h1><section><ul><li><p>We utilize private IPs behind a network in order to not run out of IPV4 addresses as fast</p></li><li><p>However, private IPs cannot be used for communcation outside the network, so how do computers with a private IP send and receive messages?</p></li><li><p>All datagrams crossing the public-private network threshold must be relabeled by the router</p></li><li><p>The NAT router must:</p><ul><li><p>Replace (source IP, port #) of every outgoing datagram with (NAT IP, new port #)</p></li><li><p>Remember in a NAT Translation table, the mapping between (source IP, port #) to (NAT IP, new port #)</p></li><li><p>Replace the (NAT IP, new port #) of every incoming datagram with (source IP, port #)</p></li></ul></li><li><p><img src="media/nat_1.png" style="max-width: 500px; min-width: 200px"></img></p></li></ul></section><h1>ICMP</h1><section><ul><li><p>ICMP is a message carried an a header that happens after the <a href="id:c66bc940-0321-468b-86c1-21ae30542ab4">IP</a> header</p></li><li><p>It defines a few different codes for functions of network functionality</p></li><li><p><img src="media/icmp_1.png" style="max-width: 500px; min-width: 200px"></img></p></li></ul></section></main>
</body>
</html>
