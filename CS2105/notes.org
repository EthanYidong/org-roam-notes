:PROPERTIES:
:ID:       D1F12114-39AC-40DC-98D0-7B6F67DEC041
:END:

#+title: CS2105 Notes
#+filetags: :CS2105:

- links :: [[id:192A0605-67DE-4277-9FEF-5C16C81937F8][CS2105]]

* Internet
:PROPERTIES:
:ID:       3E696C35-46F4-4C10-98C9-584A8D60616C
:END:

- Internet is made up of routers
  - Data packets are sent through the network from source to destination

* Data Transmission
:PROPERTIES:
:ID:       A6B358C8-8DF4-4D6D-84C3-E91031768743
:END:
- Packet switching
  - Users under the same router share its resources
  - Resources are not reserved, used on demand
    - A result of this is that packets may take different paths
    - Congestion is possible
  - Bits sent over a link which represent packets
    - Timing is a product of maximum bandwidth and propagation delay
  - Routers implement store and forward
    - Entire packet must reach the router before it will forward to the next stop in the network
    - This adds additional delay to the transmission
    - This is for the purpose for:
      - Integrity Checks

* Network Conditions
:PROPERTIES:
:ID:       EC0E367A-1B1E-4ED4-B493-B1AF845FF108
:END:

- links :: [[id:1F24CF84-A241-4317-AC6D-C4C4683F34DF][CS2105 Exams]]
** Packet Loss
:PROPERTIES:
:ID:       1D1E365F-4870-4C9D-ADE5-054FF94FA514
:END:
- Packet loss may occur when the router's buffer is full
- Connectivity issues may occur (both wired and wireless)
- Signal noise may result in corrupted packets

** Packet Delay
:PROPERTIES:
:ID:       86A82389-CC39-4780-8D82-E05918A03EFF
:END:

*** Processing Delay
:PROPERTIES:
:ID:       83010D99-9421-44DC-B1B7-9350ED7945B6
:END:
- Generally ignored
- How long it takes to process the packet (check for integrity, determine what to do with the packet)

*** Queueing Delay
:PROPERTIES:
:ID:       8AA81F32-434F-47F8-BE09-B6162306640D
:END:
- Generally ignored
- Time taken waiting for the router to finish processing packets that arrived before

*** Transmission Delay
:PROPERTIES:
:ID:       8C08E406-EC45-4D89-BF95-FE4A5A5505FE
:END:
- Limited by bandwidth of the connection
- "How long do I have to wait before can I send the next bit?"
- \(\frac{\text{bits per time}}{\text{number of bits}}\)

*** Propagation Delay
:PROPERTIES:
:ID:       5AA300BB-EFBE-4AAF-BBD3-1550EA76D34B
:END:
- Limited by the speed of the signal along the connection.
- "How long does it take for the data to go from point A to point B"?
- \(\frac{\text{length of connection}}{\text{speed of data through connection}}\)

* Network Protocols
:PROPERTIES:
:ID:       f2612135-5501-4169-a391-b27184c99a12
:END:
- The [[id:3E696C35-46F4-4C10-98C9-584A8D60616C][Internet]] supports many various kinds of network applications
  - The Web, VoIP, email, games, etc.

* Transport Services
:PROPERTIES:
:ID:       d6f93509-cb17-4d83-bd33-e41fdf15577e
:END:
- Closely tied to the [[id:dff0f2f7-2b30-48bd-8fb5-220db2076834][Transport Layer]]
- Needs:
  - Data Integrity
    - "Is the data correct?"
  - Timing
    - "Is the data recent?"
  - Throughput
    - "Is the data fast?"
  - Security

* OSI Layers
:PROPERTIES:
:ID:       e0360e0e-695b-4db0-8bda-f1ab12bd6019
:END:
- The OSI Layer Model is a structure that can be used to describe the way data is transmitted and used by computers
** Packet Layer
:PROPERTIES:
:ID:       7e0f0d9b-1e1c-4e54-ba6a-4887208ed730
:END:
- 1st layer of the [[id:e0360e0e-695b-4db0-8bda-f1ab12bd6019][OSI Layers]]
** Data Link Layer
:PROPERTIES:
:ID:       491f607a-a390-4694-8544-1fce9a3a7d86
:END:
- 2nd layer of the [[id:e0360e0e-695b-4db0-8bda-f1ab12bd6019][OSI Layers]]
- Provides communcation between adjacent nodes (connected directly over a single link, like a signal or wire)
- Datagrams from the [[id:5d0b0590-fd98-4db1-89f1-f8f38bd11bb7][Network Layer]] utilize the link layer to transmit
- Different protocols may be used for different links
- May provide:
  - Framing
    - Encapsulating datagram in a link layer frame
  - Access control
    - Ensuring the link is only used by one sender at a time
  - Error detection
    - Detect when corruption of data occurs
  - Error correction
    - Correct errors without need for retransmission
  - Reliable delivery
    - Improve reliability on error-prone links like wireless links
  - Implemented on the adapter/chips specific to the link type (wifi adapter, ethernet adapter, mobile modem)
** Network Layer
:PROPERTIES:
:ID:       5d0b0590-fd98-4db1-89f1-f8f38bd11bb7
:END:
- 3rd layer of the [[id:e0360e0e-695b-4db0-8bda-f1ab12bd6019][OSI Layers]]
- Delivers packets from sender to receiver hosts within a network
** Transport Layer
:PROPERTIES:
:ID:       dff0f2f7-2b30-48bd-8fb5-220db2076834
:END:
- 4th layer of the [[id:e0360e0e-695b-4db0-8bda-f1ab12bd6019][OSI Layers]]
- Runs in hosts:
  - Sender side:
    - Break message into segments and pass to the [[id:5d0b0590-fd98-4db1-89f1-f8f38bd11bb7][Network Layer]]
  - Receiver side:
    - Reassembles segments into message and pass to the [[id:89296f19-c817-43a7-8ef6-013e697d32ab][Application Layer]]
  - In between:
    - Check destination IP to decide routing
** Session Layer
:PROPERTIES:
:ID:       256fc6cf-5e0a-4cd0-bf54-c5b62c290dcc
:END:
- 5th layer of the [[id:e0360e0e-695b-4db0-8bda-f1ab12bd6019][OSI Layers]]
- Grouped under the [[id:89296f19-c817-43a7-8ef6-013e697d32ab][Application Layer]] for [[id:192A0605-67DE-4277-9FEF-5C16C81937F8][CS2105]]
** Presentation Layer
:PROPERTIES:
:ID:       4c5e16a5-d378-40ca-875b-566705d10018
:END:
- 6th layer of the [[id:e0360e0e-695b-4db0-8bda-f1ab12bd6019][OSI Layers]]
- Grouped under the [[id:89296f19-c817-43a7-8ef6-013e697d32ab][Application Layer]] for [[id:192A0605-67DE-4277-9FEF-5C16C81937F8][CS2105]]
** Application Layer
:PROPERTIES:
:ID:       89296f19-c817-43a7-8ef6-013e697d32ab
:END:
- 7th layer of the [[id:e0360e0e-695b-4db0-8bda-f1ab12bd6019][OSI Layers]]

* The Web
:PROPERTIES:
:ID:       d81d3738-a08e-498a-ae6b-1118a0341de1
:END:
- An application of the [[id:3E696C35-46F4-4C10-98C9-584A8D60616C][Internet]]
* TCP
:PROPERTIES:
:ID:       458a323f-763b-458e-9ce8-7b7fb008a473
:END:
- [[id:dff0f2f7-2b30-48bd-8fb5-220db2076834][Transport Layer]] protocol
- Well ordered
- [[file:media/transport-diagram-tcp_1.png][TCP]]
- Properties:
  - Point-to-Point: one sender, one receiver
  - Connection-oriented: requires handshake before sending of data
  - Full duplex: bidirectional sending of data
  - Reliable: guaranteed to get an in-order, correct reassembly of the sent data
- Connection is defined by src IP, src port, dest IP, dest port
- TCP will break the message into packets. The maximum segement size (MSS) is typically 1460 bytes, with a 20 byte header
- Header contains:
  - [[file:media/tcp-header_1.png][Header]]
- Sequence #
  - First one is randomly chosen
  - Randomized to provide some distinctions between repeat connections
  - Subsequent ones are equal to the first one plus the byte number of the first byte of the data in sequence.
- Ack #
  - Equal to the sequence number of the first byte in sequence not received as part of the stream
- [[file:media/tcp-seq-ack_1.png][Example]]
- TCP does not specify how the receiver should handle out-of-order packets
- [[file:media/tcp-diagram_2.png][Diagram 2]]
- [[file:media/tcp-diagram_3.png][Diagram 3]]
  - ? = 105, because byte 105 is the first byte not received
- Timeout
  - Timeout must be set based on the connection state
  - It is dynamically calculated based on the connection speed
  - [[file:media/tcp-timeout_1.png][Timeout]]
- Because the timeout may be long, TCP also has a mechanism to resend packets assumed to be lost, known as fast resend
  - If 4 identical ACKs, then TCP will assume the packet after the acked packet was lost
- [[file:media/tcp-fast-resend_1.png][Fast Resend]]
- Establishing the connection: handshake
  - [[file:media/tcp-connect_1.png][Connect]]
- Closing the connection:
  - [[file:media/tcp-close_1.png][Close]]
* UDP
:PROPERTIES:
:ID:       be4e6279-b595-4fcf-befc-06d57273d988
:END:
- [[id:dff0f2f7-2b30-48bd-8fb5-220db2076834][Transport Layer]] protocol
- No ordering
- Adds very little to [[id:c66bc940-0321-468b-86c1-21ae30542ab4][IP]]
  - Multiplexing data on the sender into many packets
  - Demultiplexing packets on the receiver into the original data
  - Checksum
- When a UDP receiver receives a UDP segment,
  1. It checks the destination port from the segment
  2. The UDP segment is sent to the socket for that port
  3. IP Datagrams (with possibly different sources) with the same port are directed to the same UDP port
- [[file:media/transport-diagram-udp_1.png][UDP]]
- Checksum calculation:
  - Treat the segment as a sequence of 16-bit integers
  - Add all 16-bit integers in the sequence together
  - Any carries are also added to the checksum in the lowest significant bit
  - Get the 1s complement to find the checksum
    - This is just flipping all the bits
* Round Trip Timing
:PROPERTIES:
:ID:       be2e19da-7142-44a9-8707-6e6f3412d46f
:ROAM_ALIASES: RTT
:END:
- The amount of time taken for a packet to be sent from client to server and for a reply to be received.
* HTTP
:PROPERTIES:
:ID:       b8499489-7b0e-4fbe-a5aa-367e4cf88e81
:END:
- The [[id:89296f19-c817-43a7-8ef6-013e697d32ab][Application Layer]] protocol for [[id:d81d3738-a08e-498a-ae6b-1118a0341de1][The Web]]
- Uses [[id:458a323f-763b-458e-9ce8-7b7fb008a473][TCP]] as the [[id:dff0f2f7-2b30-48bd-8fb5-220db2076834][Transport Layer]]
** HTTP 1.0
:PROPERTIES:
:ID:       7f45ae07-bd4b-4322-8d0f-77a2c1fb90e2
:END:
- links :: [[id:1F24CF84-A241-4317-AC6D-C4C4683F34DF][CS2105 Exams]]
- Non-persistant HTTP connection
  - Each object needs 2 [[id:be2e19da-7142-44a9-8707-6e6f3412d46f][RTTs]]
  - Time taken to send data is based on [[id:86A82389-CC39-4780-8D82-E05918A03EFF][Packet Delay]]
  - Timing of message = \(2 \times \text{RTT} + \text{HTTP Header Time} + \text{Data Time}\)
  - Note that speed is often given in bits per second, while size is given in bytes.

** HTTP 1.1
:PROPERTIES:
:ID:       279fe9cd-959c-49e1-839f-712e446c45e9
:END:
- links :: [[id:1F24CF84-A241-4317-AC6D-C4C4683F34DF][CS2105 Exams]]
- Persistant HTTP connection
  - The TCP connection is opened once across all objects (1 [[id:be2e19da-7142-44a9-8707-6e6f3412d46f][RTT]])
  - Multiple objects can be grouped together with one request, so each group also requires one request (1 [[id:be2e19da-7142-44a9-8707-6e6f3412d46f][RTT]])
    - This occurs when the client knows that it needs multiple resources to be fetched.
  - If there is time where the computer does not know what it needs to be fetching, it will need to idle until it knows.
  - Time taken to send data is based on [[id:86A82389-CC39-4780-8D82-E05918A03EFF][Packet Delay]]
  - Timing across all messages = \(\text{RTT} \times (\text{Number of Objects} + 1) + \text{Data Time} + \text{Idle Time}\)
  - Note that the speed is often given in bits per second, while size is given in bytes.
* IP
:PROPERTIES:
:ID:       c66bc940-0321-468b-86c1-21ae30542ab4
:END:
- [[id:5d0b0590-fd98-4db1-89f1-f8f38bd11bb7][Network Layer]] service of the internet
- Runs within routers between the sender and receiver hosts
  - Routers will read the IP header to determine where to send the packet
- IP header, which is added on to every datagram, is 20 bytes for IPV4
  - [[file:media/ip-header_1.png][Diagram]]
- IPV6:
  - [[file:media/ipv6-header_1.png][Diagram]]
** Fragmentation
:PROPERTIES:
:ID:       5f3f8977-96ff-4c27-84d1-9bbe9fa3e859
:END:
- Different network have a different Max Transfer Unit, the maximum amount of data a [[id:491f607a-a390-4694-8544-1fce9a3a7d86][Data Link Layer]]-level frame can carry
- IP datagrams that are too large may be fragmented by routers
- Destination will reassemble the packet
- Note that this occurs independantly of the transport layer protocols; the network layer has no knowledge of the structure of TCP or UDP.
- [[file:media/fragment_1.png][Fragment]]
* [[id:c66bc940-0321-468b-86c1-21ae30542ab4][IP]] Address
:PROPERTIES:
:ID:       11fd492e-05ef-4acd-818c-60fdcc28ae46
:END:
- 32 bit(IPv4) or 128 bit(IPv6) that identifies a node in a network
  - Both Hosts and Routers
- IPv4 addresses look like [0-255].[0-255].[0-255].[0-255]
- IPv4 blocks look like [0-255].[0-255].[0-255].[0-255]/N
  - N denotes the number of constant bits at the front
  - IP addresses can be split into two parts, the subnet prefix and the hosst ID
- IP addresses are associated with a [[id:16c49997-a487-4021-b7d1-a91b09859d1d][Network Interface]]
** Special IP Addresses
:PROPERTIES:
:ID:       d888ff99-23b4-4f35-a91f-983d77c9b1ef
:END:
- 0.0.0.0: Non-routable meta-address, special use
- 127.0.0.0/8: Loopback address, sends to the host
  - Originally 127.0.0.1/32
- Private addresses
  - 10.0.0.0/8
  - 172.16.0.0/12
  - 192.168.0.0/16
- 255.255.255.255/32
  - Broadcast address, which will send a message to all hosts on that subnet
** IP Address Allocation
:PROPERTIES:
:ID:       160b1d3b-04d0-4162-b7be-501077aacb5b
:END:
- Organizations will buy IP addresses from a registry or rent from their ISP
- ISPs get their blocks from ICANN
* Domain Name System
:PROPERTIES:
:ID:       a3ae3cdc-5328-402e-8c47-177e942fa4fb
:ROAM_ALIASES: DNS
:END:
- Two ways to identify a host:
  - Hostname: www.example.org
  - [[id:11fd492e-05ef-4acd-818c-60fdcc28ae46][IP Address]]: 93.184.216.34
- Hostnames are easier to remember, but computers can only use IP addresses to communicate
- DNS is an [[id:89296f19-c817-43a7-8ef6-013e697d32ab][Application Layer]] protocol which allows computers to find the IP address associated with a host name
- These calls are made by browser when attempting to visit a [[id:d81d3738-a08e-498a-ae6b-1118a0341de1][Website]]
- Can lookup using nslookup or dig
  - nslookup <domain>
  - dig <type?> <domain> <"+short"?>
- DNS uses [[id:be4e6279-b595-4fcf-befc-06d57273d988][UDP]] for speed
  - UDP is unreliabale but DNS does not need reliability
  - Locally served DNS has lower chance of packet loss
  - Browsers can send multiple identical DNS requests
** DNS Servers
:PROPERTIES:
:ID:       021e6dab-9bc6-4432-bddb-6010e378a3bd
:END:
- DNS servers exist in a hierarchy
  - Root server on top
  - TLD servers next
  - Then authoritative domain servers
  - ...
** Local [[id:021e6dab-9bc6-4432-bddb-6010e378a3bd][DNS Servers]]
:PROPERTIES:
:ID:       755c25c6-acc8-4bb8-80ef-2495f0919ade
:END:
- A DNS Server hosted within a LAN, such as your workplace, your ISP, your school, your house
- The Local DNS Server is "Non-authoritative"
- Querys and records are [[id:7a342c16-c2cd-4098-9326-17e0e9654c0b][Cached]] locally to speed up request fufillment
** DNS Cacheing
:PROPERTIES:
:ID:       7a342c16-c2cd-4098-9326-17e0e9654c0b
:END:
- Records are saved locally as a cache to speed up repeated [[id:a3ae3cdc-5328-402e-8c47-177e942fa4fb][DNS]] requests
- Life is based on the TTL property of a DNS record
** Resource Records
:PROPERTIES:
:ID:       46f135e4-e2fa-422f-a038-677b08ddcda0
:END:
- Format of DNS records
- Maps between host and IP address
- (name, value, type, ttl)
  - Name is the hostname, i.e. www.example.com
  - Value is the value mapped to the hostname, i.e. 93.184.216.34
  - [[id:1cb6721f-2c5a-40a0-a447-58e3bc3aea04][Type]]: the type of entry
  - TTL: Time to Live ([[id:7a342c16-c2cd-4098-9326-17e0e9654c0b][DNS Cache]] life)
** Record Types
:PROPERTIES:
:ID:       1cb6721f-2c5a-40a0-a447-58e3bc3aea04
:END:
*** A
:PROPERTIES:
:ID:       93b7ce91-aa85-4195-a528-c342661a9aa3
:END:
- "Alias"
- Name is the hostname
- Value is the ip address the name maps to
*** CNAME
:PROPERTIES:
:ID:       5bfc5249-36a9-43f8-83a6-9c185adc2ffa
:END:
- "Canonical name"
- Name is the alias name
- Value is the canonical location that the alias name maps to
- Essentially operates like [[id:93b7ce91-aa85-4195-a528-c342661a9aa3][A]] but value is a hostname
*** NS
:PROPERTIES:
:ID:       6d582497-506c-4e29-9dfc-042e996ecb9a
:END:
- "Name Server"
- Name is the domain
- Value is the name server
- The name server provides the hostname of the canonical nameserver which is in charge of providing values to the [[id:a3ae3cdc-5328-402e-8c47-177e942fa4fb][DNS]]
*** MX
:PROPERTIES:
:ID:       bae007b2-3ece-432c-bb20-abc5283f589f
:END:
- "Mail Exchanger"
- Name is the domain
- Value is the mail server
* Addressing
:PROPERTIES:
:ID:       4201faab-cb57-4a69-992a-fd9328ac0dd4
:END:
- [[id:11fd492e-05ef-4acd-818c-60fdcc28ae46][IP Addresses]] are used to identify hosts
- This is not however, because many different applications might be running on the host
- Applications are identified by using a port number (16 bits)
  - Ports 1-1023 are reserved
- Example Ports:
  - 80: HTTP server
  - 25: SMTP server
* Socket
:PROPERTIES:
:ID:       b9e8bfd8-a7b3-4e36-806f-f58eeebc3283
:END:
- Sockets are an interface that sit between the [[id:89296f19-c817-43a7-8ef6-013e697d32ab][Application Layer]] and [[id:dff0f2f7-2b30-48bd-8fb5-220db2076834][Transport Layer]]
- Applications treat the internet like a black box, and communicate only using the socket
- [[id:be4e6279-b595-4fcf-befc-06d57273d988][UDP]]:
  - Socket has no connection, packets are all sent as they are to the server and port
  - [[file:media/udp-diagram_1.png][UDP Diagram]]
- [[id:458a323f-763b-458e-9ce8-7b7fb008a473][TCP]]:
  - A connection must first be established
  - Server creates a socket for each client
  - [[file:media/tcp-diagram_1.png][TCP Diagram]]
  - Note: In the [[id:1F24CF84-A241-4317-AC6D-C4C4683F34DF][Exam]], make sure to count a +1 for the welcome socket
* Bytes vs Bits
:PROPERTIES:
:ID:       143f2320-d086-44d1-bcd3-41332fde6116
:END:
- If the b is lowercase (b, Kb, Mb, ...), then it refers to bits
- If the B is uppercase (B, KB, MB), then it refers to bytes
* Topology
:PROPERTIES:
:ID:       f7c55006-b0a3-4842-b668-0be675ac1aab
:END:
- Minimal:
  - Tree topology
    - Organized in a tree
  - Chain topology
    - Special case of tree topology where every node has at most one child
  - Star topology
    - Special case of tree topology where one node has all the children
- Maximal:
  - Mesh
    - Fully connected
* Reliable Data Transfer
:PROPERTIES:
:ID:       074a6a63-d7ce-4112-972f-58fa072d2a0e
:ROAM_ALIASES: RDT
:END:
- "Sending data reliably over the internet is hard"
- Question: how do we build a reliable [[id:dff0f2f7-2b30-48bd-8fb5-220db2076834][Transport Layer]] protocol on top of an unreliable [[id:5d0b0590-fd98-4db1-89f1-f8f38bd11bb7][Network Layer]]?
- The network may:
  - Corrupt packets
  - Drop packets
  - Reorder packets
  - Deliver packets after an arbitrary delay
- Our reliable transport service should:
  - Guarantee packet delivery and correctness
  - Deliver packets in the same order that they are sent
- [[file:media/rdt-protocol_1.png][RDT Protocol]]
* Toy [[id:074a6a63-d7ce-4112-972f-58fa072d2a0e][RDTs]]
:PROPERTIES:
:ID:       111511f6-3caf-4fd8-848e-414646b24187
:END:
- [[file:media/toy-rdt_1.png][Chart]]
** Toy RDT 1.0
- Assume that the channel is 100% reliable
- We just have to simply send the packets as is
- We get this [[id:6ec79c40-1a4a-4f24-b947-dc6cb3611532][FSM]]:
- [[file:media/toy-rdt-1.0_1.png][Example]]
** Toy RDT 2.0
 - Assume that the channel may flip bits
 - Other than that, the channel is 100% reliable
 - We can detect errors with a checksum
 - Use ACK (acknowledge) and NAK (negative acknowledge) on the receiver side to tell the sender whether or not the packet was ok
 - This is a [[id:f4930941-2e92-4fff-a7b3-4ee7f8583e60][Send-and-Wait Protocol]]
 - [[file:media/toy-rdt-2.0_1.png][Demo]]
 - We get this [[id:6ec79c40-1a4a-4f24-b947-dc6cb3611532][FSM]]:
 - [[file:media/toy-rdt-2.0_2.png][Example]]
 - Flaw: what happens when the ACK or NAK is corrupted?
   - Can the sender just resend the packet if it receives garbled feedback?
** Toy RDT 2.1 (2.0 w/ Packet Sequence #)
- Include the sequence number to each packet
- Receiver can discard packets that have already been received
- [[file:media/toy-rdt-2.1_1.png][Demo 1]]
- [[file:media/toy-rdt-2.1_2.png][Demo 2]]
- We get this [[id:6ec79c40-1a4a-4f24-b947-dc6cb3611532][FSM]]:
- [[file:media/toy-rdt-2.1_3.png][Example Sender]]
- [[file:media/toy-rdt-2.1_4.png][Example Receiver]]
** Toy RDT 2.2 (2.1 w/out NAK)
- Instead of sending NAK for corrupted packets, instead send ACK for the previous correct packet
- [[file:media/toy-rdt-2.2_1.png][Demo]]
** Toy RDT 3.0
:PROPERTIES:
:ID:       7a3e843b-8568-45e8-9af3-9d963ba4b722
:END:
- Assume that the channel may flip bits, lose packets, and may have arbitrarily long delay
- Will not reorder packets
- How do we detect packet loss, since the delay can be arbitrary?
- Set a reasonable timeout value to trigger an assumption that the packet is lost, so the sender will resend if an ACK is not received in time
- If the packet is delayed and timeout is triggered, this means that a duplicate will have been sent.
- [[file:media/toy-rdt-3.0_1.png][Demo 1]]
- [[file:media/toy-rdt-3.0_2.png][Demo 2]]
- We get this [[id:6ec79c40-1a4a-4f24-b947-dc6cb3611532][FSM]]:
- [[file:media/toy-rdt-3.0_3.png][Example Sender]]
- Receiver is about the same as Toy RDT 2.1
* Finite State Machines
:PROPERTIES:
:ID:       6ec79c40-1a4a-4f24-b947-dc6cb3611532
:ROAM_ALIASES: FSM
:END:
- A finite state machine is defined by a finite set of states and a set of transitions between states
- [[file:media/example-fsm_1.png][Example]]

* Send-and-Wait Protocol
:PROPERTIES:
:ID:       f4930941-2e92-4fff-a7b3-4ee7f8583e60
:END:
- This is a protocol which requires senders to wait for a response after each packet is sent.

* Pipelining Protocol
:PROPERTIES:
:ID:       a63ee94c-54af-43e8-acd7-199f0577f6d5
:END:
- A protocol which allows senders to send multiple un-acknowledged responses at once
** Go-Back-N
:PROPERTIES:
:ID:       362bcf01-6358-4517-850d-7976dc2b089e
:END:
- [[file:media/go-back-N_1.png][Diagram]]
- Send multiple packets at once
- Receiving out-of-order or invalid packets will cause the receiver to re-acknowledge the last well-ordered packet
- Receiving repeat acknowledgements will be ignored, then the sender will calculate the last acknowledged packet
- Uses a window size "N" which indicates the maximum number of unacknowledged packets to be sent
** Selective Repeat
:PROPERTIES:
:ID:       6a576a73-58ab-4fe1-adce-fde423ec2119
:END:
- [[file:media/selective-repeat_1.png][Diagram]]
- [[file:media/selective-repeat_2.png][Diagram 2]]
- Send multiple packets at once
- All valid received packets will be acknowledged
- Sender keeps a timer for all unacknowledged packets
- Resend unacked packets on timeout
- More efficient than [[id:362bcf01-6358-4517-850d-7976dc2b089e][Go-Back-N]], but more complicated, as everything may be out of order
- Also keeps a window size, and the window is guaranteed to contain all unacked packets

* Speed of [[id:f4930941-2e92-4fff-a7b3-4ee7f8583e60][Send-and-Wait Protocol]] and [[id:a63ee94c-54af-43e8-acd7-199f0577f6d5][Pipelining Protocol]]
- Send and wait implementations such as [[id:7a3e843b-8568-45e8-9af3-9d963ba4b722][Toy RDT 3.0]] are generally very slow because the sender must wait for a reply every time it wants to send a packet, leading to a vast underutilization of the bandwidth
- Pipelining: send multiple un-acknowledged packets at once
- Sending 3 packets at once multiplies the utilization by 3
* DHCP
:PROPERTIES:
:ID:       c12c24ab-126a-45fd-8b2c-2e95e9876f8f
:END:
- A protocol which allows hosts to dynamically obtain an [[id:11fd492e-05ef-4acd-818c-60fdcc28ae46][IP Address]] when it joins a network
- Renewable
- Allows reuse of address (hosts can only hold an address while connected)
- 4 steps:
  1. Host broadcasts DHCP discover
  2. DHCP server responds with a DHCP offer message
  3. Host requests an IP address with a DHCP request messages
  4. DHCP server will respond with a DHCP ack
- Note that the apparent "redundancy" occurs because there may be multiple DHCP servers in a network
- DHCP may also provide the router IP, local [[id:a3ae3cdc-5328-402e-8c47-177e942fa4fb][DNS]] IP, as well as the [[id:355ba6f2-81ee-4124-9d6a-29c26024ccb8][Subnet Mask]]
- [[file:media/dhcp_1.png][Diagram]]
* Network Mask
:PROPERTIES:
:ID:       fd2506eb-6c99-4546-9514-c972a9112c0d
:END:
- INdicates the network prefix vs host ID of an IP address
* Network Interface
:PROPERTIES:
:ID:       16c49997-a487-4021-b7d1-a91b09859d1d
:END:
- An interface which enables a computer to connect to a network
- For example
  - WiFi
  - Ethernet
- A host will usually have one or two, and a router may have many
* Subnet
:PROPERTIES:
:ID:       369efc83-fcbc-437c-8aee-e1037bb0877c
:END:
- A network formed by directly connected computers
- Subnets are assigned a IP address prefix
** Subnet Mask
:PROPERTIES:
:ID:       355ba6f2-81ee-4124-9d6a-29c26024ccb8
:END:
- Set all the subnet prefix bits to 1, and all the host ID bits to 0
- For the IP Address 192.168.1.0/24: 255.255.255.0
* Classless Inter-domain Routing
:PROPERTIES:
:ID:       1885a461-f189-49d2-a978-e6bad07506f9
:ROAM_ALIASES: CIDR
:END:
- AKA CIDR
- The method of assigning IP addresses with a subnet prefix and a host ID

* [[id:11fd492e-05ef-4acd-818c-60fdcc28ae46][IP Address]] Prefix Matching
:PROPERTIES:
:ID:       967b6e69-622b-4b0f-a4aa-87b300078e21
:END:
- Routers can request for all packets with a prefix to be routed to them after [[id:160b1d3b-04d0-4162-b7be-501077aacb5b][IP Address Allocation]]
- This is done based on the longest matching prefix, so if someone requests for 192.0.0.0/8, and someone else requests for 192.168.0.0/16, then packets with IP 192.168.1.1 will get routed to the second.

* Routing
:PROPERTIES:
:ID:       c2fa8019-df2a-4988-bcc1-51b2fa3ec40b
:END:
** Intra-AS routing
:PROPERTIES:
:ID:       4573522c-2b99-4582-b67b-69af2dae2e6b
:ROAM_ALIASES: RIP
:END:
- Routes between nodes which are part of the same [[id:c3b243ad-3fd8-4d6c-8d86-652e4bd44dce][AS]]
- If each link has a cost associated with it, the problem of intra-AS routing becomes a min cost path problem
  - Cost generally inversely related to bandwidth, or could be just constant
*** Link State
:PROPERTIES:
:ID:       07c0fa9e-5a7f-4673-8219-f74865046896
:END:
 - Each router periodically shares link cost values with the whole network
 - All routers have complete knowledge of all costs in the network
 - Uses dijkstra's algorithm to compute the best path for a packet
*** Distance Vector
:PROPERTIES:
:ID:       7caaf9c5-3359-4900-bc29-f636eefb87ef
:END:
- Router knows physically connected neighbors and will share link costs to them
- Routers will exchange "local views" with its neighbors and update its own local view based on its neighbors "local views"
  - The local view is a set of currently known shortest distances from all routers to all other routers.
  - Local views will be updated using the [[id:68aa9ceb-91e4-43be-adaf-1e0f98fe96d3][Bellman-Ford Equation]]
  - [[file:media/local-view_1.png][Local View]]
*** Routing Information Protocol
- AKA RIP
- A [[id:4573522c-2b99-4582-b67b-69af2dae2e6b][Intra-AS routing]] protocol which implements the [[id:7caaf9c5-3359-4900-bc29-f636eefb87ef][Distance Vector]] algorithm.
- Uses hop count as the cost metric (i.e. each link has cost 1), which means that it ignores network congestion
- Routing table is sent every 30 seconds over UDP port 520
- "Self-repair", meaning that if no updates have been received from a neighbor after 3 minutes, that neighbor is assumed to be failed and removed

* Autonomous System
:PROPERTIES:
:ID:       c3b243ad-3fd8-4d6c-8d86-652e4bd44dce
:ROAM_ALIASES: AS
:END:
- An ISP / other organization which owns its routers and links
- Has a clearly defined routing policy which is applied to the whole network

* Bellman-Ford Equation
:PROPERTIES:
:ID:       68aa9ceb-91e4-43be-adaf-1e0f98fe96d3
:END:
- \(d_x(y)=min_v\{c(x,v)+d_v(y)\}\) across all neighbors v of x
  - Where \(d_x(y)\) is the minimum distance from x to y
  - and \(c(x,v)\) is the cost of the link between x and v

* Network Address Translation
:PROPERTIES:
:ID:       6e7e0310-2256-401e-ac6f-14f15017875d
:END:
- We utilize private IPs behind a network in order to not run out of IPV4 addresses as fast
- However, private IPs cannot be used for communcation outside the network, so how do computers with a private IP send and receive messages?
- All datagrams crossing the public-private network threshold must be relabeled by the router
- The NAT router must:
  - Replace (source IP, port #) of every outgoing datagram with (NAT IP, new port #)
  - Remember in a NAT Translation table, the mapping between (source IP, port #) to (NAT IP, new port #)
  - Replace the (NAT IP, new port #) of every incoming datagram with (source IP, port #)
- [[file:media/nat_1.png][NAT]]

* ICMP
:PROPERTIES:
:ID:       13e7cc23-0551-45dd-a248-e3b532930058
:END:
- ICMP is a message carried an a header that happens after the [[id:c66bc940-0321-468b-86c1-21ae30542ab4][IP]] header
- It defines a few different codes for functions of network functionality
- [[file:media/icmp_1.png][Diagram]]
* Error Detection and Correction
:PROPERTIES:
:ID:       51250afe-1710-4b30-a63c-db51478b56e9
:ROAM_ALIASES: EDC
:END:
- Implemented for the [[id:491f607a-a390-4694-8544-1fce9a3a7d86][Data Link Layer]].
- We have an error-prone link
- Link layer protocol may include a set of Error Detection and Correction bits
- The receiver can check the data against the EDC to check the validity of the data; however, the chance of error is still non-zero.
  - Tradeoff between EDC size and false positives for correctness
- Types:
  - Checksum (used in TCP)
  - Parity Check
  - CRC (commonly used at link layer)
- Parity Check, Single bit
  - In an even parity scheme: add a single bit to the end such that the total number of 1s is even.
  - Can detect any odd number of single bit errors
  - Cannot detect an event number of single bit errors
  - Works well theoretically if errors are independent
  - However, in the real world errors are often clustered in bursts
- Parity Check, 2-D
  - Divide the bits into i rows and j columns
  - For each row and column, find the bit for the parity
  - A final parity bit is also computed from the row parity column, which mathematically is the same as the column parity row
  - The EDC is comprised of the i + j + 1 bits
  - [[file:media/2d-parity_1.png][Diagram]]
  - Can detect and correct single bit errors in data
  - Two bit errors can only be detected
  - Leads to larger overhead, but does the ability to correct single bit errors make up for it?
- Cyclic Redundancy Check
  - Pretend we can work in decimal:
    - Choose a number of digits r for the EDC, and a generator G with r digits
    - Create a new data X by appending r 9's digits to D
      - (\(X=D \times 10^r+(10^r-1)\))
    - Find the remainder y = X % G
    - Transmit M = X - y
    - M is divisible by G
    - Mathematically, the original data will be preserved by this operation, with a new set of 3 digits tacked on which makes the end product divisible by G
  - For binary:
    - G must have r + 1 bits
    - Calculations are done modulo 2, meaning no carries or borrows will be used, making addition and subtraction equivalent to XOR.
    - Before dividing, we append r 0's to D
    - By the properties of modulo 2 arithmetic, the remainder X % G is actually the r bits which we need to append to the data to make it divisible by G
    - [[file:media/crc-division_1.png][Diagram]]
      - Note the special type of subtraction done for division
    - [[file:media/crc-wiki_1.png][Wiki]]
  - Easy to implement in hardware
  - Can detect all odd single bit errors
  - Can detect all burst errors of less than r + 1 bits
  - Can detect all burst errors of greater than r bits with probability \(1-0.5^r\)
  - CRC is a "polynomial code"
* Link Access Control
:PROPERTIES:
:ID:       7d01f5b2-39cb-40c5-822b-b5ac643f220b
:END:
- Implemented at the [[id:491f607a-a390-4694-8544-1fce9a3a7d86][Data Link Layer]]
- Two types of network links
  - Point-to-Point
    - Sender and Receiver directly connected by a dedicated link
    - No need for multiple access control
    - Implements protocols like Point-to-Point Protocol, or Serial Line Internet Protocol
  - Broadcast Link
    - Multiple nodes connected to a shared broadcast chnanel
    - E.X. Wi-Fi
    - When a node transmits a frame, the channel broadcasts the frame and every other node receives a copy.
- Problem: In a broadcast channel, if two or more nodes transmit simultaneously, a receiver may occur if a node receives two or more signals.
- When, and how long should each host be allowed to transmit?
- Ideas
  - Random Access
    - No coordinations, collisions are possible
    - Recover from collisions
  - Taking Turns
    - Each host takes turn to transmit.
  - Channel Partitioning
    - Divide the channel into fixed pieces (by frequency, by time slots, etc.), allocated to hosts for exclusive use
- Ideally
  - Given a channel rate of R bps
  - Collision free
  - Efficient: When only one node wants to transmit, it can send at rate R
  - Fairness: When M nodes wants to transmit, they can send at average rate R/M
  - Decentralized: No need for a special node to coordinate transmissions
- Additionally, no out-of-bound channel signaling, i.e. all signaling must be done through the same channel itself.
** Time-Division Multiple Access
:PROPERTIES:
:ID:       d833fccc-20f6-4009-a425-a48735ff1873
:ROAM_ALIASES: TDMA
:END:
- Access channel in rounds
- Each node is allocated a fixed length time slot in each round
- [[file:media/tdma_1.png][Diagram]]
- Collision free, fair, and decentralized, but not efficient.
** Frequency-Division Multiple Access
:PROPERTIES:
:ID:       6eb1db19-3bdb-45eb-aea7-8258315f34a4
:ROAM_ALIASES: FDMA
:END:
- Channel is divided into frequency bands
- Each node is allocated a frequency
- [[file:media/fdma_1.png][Diagram]]
** Polling
:PROPERTIES:
:ID:       01621050-b0c5-4f97-bb6d-859c4d9b1b7c
:END:
- A master node will poll the rest of the nodes in a round robin fashion
- If the node wants to transmit, it will be allowed to transmit a certain max number of frames
- If not, the master immediately asks the next node
- Collision free, efficient, fair, but not decentralized
  - Only small overhead of polling
- [[file:media/polling_1.png][Diagram]]
** Token Passing
:PROPERTIES:
:ID:       e569fe76-ce9a-41f0-b3d9-993636c83764
:END:
- A special token is passed from one node to the next, sequentially
- A node only transmits when it has the token
- It passes the token to the next node if it has nothing left to transmit, or after it has transmitted the maximum allowed
- Collision free, efficient, fair, and decentralized
  - Only small overhead of token passing
  - Fairness relies on proper implementation
  - Complexity: token loss or node failure can be disruptive
** Random Access
:PROPERTIES:
:ID:       5c55c17f-1eb7-4daf-9eab-e2d95eb6fbc8
:END:
- Node transmits whenever it has data to send
- If collisions detected, attempt to recover
*** Slotted ALOHA
:PROPERTIES:
:ID:       13568fe6-9fbe-4cd5-b09c-94ec761bb342
:END:
- All frames have equal length
- Divide time slots into equal length equal to the time taken to transmit one node
- Transmit only at the start of time slots
- If no collision is detected, success
- If collision detected, for each subsequent slot, retransmit with a set probability p
- Efficient-ish, fair, decentralized, but not collision-free
  - Slots are wasted by collision and being empty when there is data to be transmitted
  - 37% usage with multiple nodes
- [[file:media/slotted-aloha_1.png][Diagram]]
*** Pure ALOHA
:PROPERTIES:
:ID:       e3cab473-c606-4ca4-a75c-aa56f91bb9ee
:ROAM_ALIASES: "Unslotted ALOHA"
:END:
- Same as [[id:13568fe6-9fbe-4cd5-b09c-94ec761bb342][Slotted ALOHA]] but without time slots or synchronization
- Transmit whenever you have data
- If no collision, success
- If collision, wait one frame's trasmission time and retransmit with probability p
- Chance of collision has increased
- Less efficient-ish, fair, decentralized, but not collision-free
  - 18% usage with multiple nodes
- [[file:media/pure-aloha_1.png][Diagram]]
*** Carrier Sense Multiple Access
:PROPERTIES:
:ID:       dc6aaa9f-653f-444b-9b04-15efa7063af8
:ROAM_ALIASES: CSMA
:END:
- Weakness of [[id:e3cab473-c606-4ca4-a75c-aa56f91bb9ee][ALOHA]]: a node's decision to transmit is made independently of the activity of other nodes
- Idea: sense if the link is idle, if it is busy then defer transmission
- Collisions still occur: propagation delay may mislead a node into thinking the link is idle
- Efficient, fair, and decentralized, but not collision-free
- [[file:media/csma_1.png][Diagram]]

*** CSMA/Collision-Detection
:PROPERTIES:
:ID:       24bd1461-3b29-407a-b5fb-b8d802df6b64
:ROAM_ALIASES: CSMA/CD
:END:
- Weakness of [[id:e3cab473-c606-4ca4-a75c-aa56f91bb9ee][ALOHA]] and [[id:dc6aaa9f-653f-444b-9b04-15efa7063af8][CSMA]]: A node does not stop transmitting after collision detected
- Idea:
  - If link is idle: send
  - If link is busy: defer transmission
  - If collision is detected: abort transmission, and retransmit after a random delay
- [[file:media/csma-cd_1.png][Diagram]]
- In ALOHA, the chance of collision doesn't really decrease for the subsequent time slots
- Adapt retransmission to the current load
- Apply a binary exponential backoff
  - After first collision, chooose a delay K from 0 or 1, and wait for K time units
  - After second collision, choose a delay K from 0, 1, 2, 3, and wait for K time units
  - After n collisions, choose the delay K from 0 to \(2^{n} -1\)
  - More collisions means the node assumes higher load and will adjust the delay accordingly
- If frame size is too low relative to propagation delay, then collisions may not be detected by the sender:
  - [[file:media/small-frame-size_1.png][Small Frame Size]]
- Efficient, fair, and decentralized, but not collision-free
* MAC Address
:PROPERTIES:
:ID:       7160475c-965e-49a9-b7ac-503d332f7685
:END:
- AKA Physical address
- Used to indicate which hardware is intended to receive a certain frame within a broadcast medium
- If the frame is labeled with your MAC address, the frame is accepted, otherwise it is ignored
- Typically 48 bits and set within the ROM (read only memory) of the network hardware
  - Sometimes can be software settable
- Allocating is managed by IEEE, which uses the first three bytes to identify the vendor
- FF:FF:FF:FF:FF:FF is the broadcast MAC address
* Local Area Network
:PROPERTIES:
:ID:       4b275b75-30fc-452a-9134-2c4f5ce5fee4
:ROAM_ALIASES: LAN
:END:
- A computer network whcih exists within a restricted geographical area
- Utilizes technologies:
  - IBM Token Ring (IEEE 802.5)
  - Ethernet (IEEE 802.3)
  - Wi-Fi (IEEE 802.11)
* Ethernet
:PROPERTIES:
:ID:       d273e252-048d-43d5-a495-67e40377f589
:END:
- The dominant [[id:4b275b75-30fc-452a-9134-2c4f5ce5fee4][LAN]] wired technology
- Made up of many different standards which each handle different speeds and different physical layers (wire, fiber optics)
- [[file:media/ethernet_1.png][Diagram]]
  - "Data" will generally be an IP/network layer frame
  - Max size (MTU): 1500 bytes
  - Minimum size: 46 bytes (used to ensure that collision will be detected)
  - Type indicates a higher layer protocol (not only [[id:c66bc940-0321-468b-86c1-21ae30542ab4][IP]], but also others such as ARP, AppleTalk, etc.)
  - Preamble is 7 bytes containing the pattern 10101010 (AA, "wake up"), then 1 byte of 10101011 (AB, "start of frame")
    - Synchronizes receiver and sender clock rates
- Reliability:
  - The receiver will not use ACK/NAK packets to the sender, so data in the dropped frames will be left dropped in the higher layers will only get recovered if a higher level [[id:074a6a63-d7ce-4112-972f-58fa072d2a0e][RDT]] is used such as [[id:458a323f-763b-458e-9ce8-7b7fb008a473][TCP]]
- [[id:7d01f5b2-39cb-40c5-822b-b5ac643f220b][Link Access Control]]:
  - Uses [[id:24bd1461-3b29-407a-b5fb-b8d802df6b64][CSMA/CD]] with binary backoff
** Physical Topology
:PROPERTIES:
:ID:       0d608820-1a9a-4c1b-989f-e1638b55f57a
:END:
- How do we connect multiple Ethernet devices?
- Devices:
  - Hub: cheap but slow
    - Lives on the physical layer and just blindly sends electrical signals between everything connected to it
  - Switch: expensive but fast
    - See [[id:40ea0457-df89-43a9-b4f9-0a62b793bd5d][Switch]]
- Topology is a description of how devices are connected to each other:
  - Bus Topology:
    - Very popular leading to the mid 90s
    - All nodes connect to a single, common bus
    - All frames get sent to all nodes along the bus
    - Collisions are very likely
    - The cable becomes the single point of failure, and if it is very long then fixing and troubleshooting is hard.
    - Not good for large networks, but ok for small networks
  - Star Topology with Hub:
    - All nodes connect to a hub
    - Hub amplifies and transmits bits received to all connected devices
    - Cheap and easy to maintain
    - Much easier to troubleshoot and fix (if one device broken, then its link is probably broken, if many devices broken, then likely it's the hub)
  - Star Topology with Switch:
    - Popular since the early 2000's
    - All nodes connect to a switch
    - Switch acts as a traffic controller to eliminate collisions
    -
** Switch
:PROPERTIES:
:ID:       40ea0457-df89-43a9-b4f9-0a62b793bd5d
:END:
- Lives on the data link layer meaning that it interprets the bits as an ethernet frame
- Buffers received frames and sends them later to avoid collisions
- Selectively forwards frames to its destination
  - This allows simultaneous sending of packets from A to B and C to D
- Nodes are unaware of the switch
- No configuration needed, can be directly swapped with a hub to increase network performance
- Switches can be connected in hierarchy - requires them to have their own routing protocol
- Self learning:
  - Switch maintains a routing table
    - Includes a TTL to clear old entries
    - TTL will be refreshed upon receiving new packets from the same source
    - Duplicate entries are allowed
    - If a machine is moved, incoming packets will be lost until the moved machine sends a frame
  - When receiving a frame from a certain interface, the sender of that frame is recorded in the table as being connected through that interface
- Routing
  - If the destination [[id:b534f6fc-0a19-4899-b0cd-d690668fdce5][MAC]] is contained within the table, then send to that specific interface
  - Otherwise, we have to send to all interfaces other than the sender's interface because we do not know on which interface that device is connected
  - [[file:media/switch_1.png][Routing]]
  - Special cases for when the switch knows that the packet already exists within certain interfaces - will not resend
** Address Resolution Protocol
:PROPERTIES:
:ID:       af9bdbfd-8d1d-4315-ba77-8e741f407189
:END:
- The mechanism by which we determine the corresponding [[id:b534f6fc-0a19-4899-b0cd-d690668fdce5][MAC]] address of a host with a certain IP address
  - "I want to send a frame to the IP address ___, what should I set the destination MAC to?"
- Each device will store an ARP table similar to a DNS table, which allows the device to lookup an IP address to find a corresponding MAC address
- Local (same subnet):
  - If the device is not contained within the ARP table, then the sender will broadcast an ARP query packet (to FF:FF:FF:FF:FF:FF) with the receiver's IP address, then the receiver will reply with an ARP frame (thus the sender can determine B's MAC using the sender's MAC address)
    - A will then store the MAC within its ARP cache table
  - [[file:media/arp-local_1.png][Diagram]]
- Different subnet:
  - The destination MAC will instead be that of the router's (which may also need to be looked up using ARP)
  - Then, the responsibility of routing is handed off to the router
  - [[file:media/arp-across_1.png][Diagram]]
