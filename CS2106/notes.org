:PROPERTIES:
:ID:       3BEC0A0C-17C5-4C68-9937-E44E79DB9C4C
:END:
#+title:CS2106 Notes
#+filetags: :CS2106:
- links :: [[id:539C8BDD-D2EA-4131-8F31-F2C3F0BC3799][CS2106]]

* QNA
:PROPERTIES:
:ID:       e1a1f936-5cb0-4093-a7da-5a375d9a8655
:END:
- Isn't the OS an overhead? Wouldn't it be better to do without?
  - It is an overhead but it is worth it in almost all cases, sometimes it can actually save on some resources
  - In some MCUs there is no OS because the computer only has one job
- What if I only have one CPU? How can it run so many things?
  - The OS can take over the CPU ("scheduled to run") and transfer control to other processes
  - Context switching
    - Register data is stored into the memory
  - Hardware is designed for interrupts to be possible
- What is system software?
  - Software in the OS that assists and services the other applications running
- How do you know how much space to allocate?
  - Compiler checks which variables you want to store
- Endianness
  - Let a value $A=0xdeadbeef$
  - Let's say we want to store this in the memory space: $0x100, 0x101, 0x102, 0x103$
  - Little Endian:
    - [[id:0a64e439-8706-4401-ab6a-71577970d7aa][MSB]] is stored in the lowest address
|  Addr |  Val |
|-------+------|
| 0x100 | 0xde |
| 0x101 | 0xad |
| 0x102 | 0xbe |
| 0x103 | 0xef |

  - Big Endian:
    - [[id:6a212478-657e-4121-a5f2-ad26de5cf35e][LSB]] stored in the lowest address
|  Addr |  Val |
|-------+------|
| 0x100 | 0xef |
| 0x101 | 0xbe |
| 0x102 | 0xad |
| 0x103 | 0xde |

* Operating System
:PROPERTIES:
:ID:       D289CD47-38F4-481F-BED1-FEAF25C4D709
:ROAM_ALIASES: OS
:END:

** Why learn OS?
- Become a better programmer
  - Know how your program is interacting with the OS.
- Become a better software engineer
  - Understand the most complicated program
- Become a better computer user
** What is an OS?
- Invented in order to allow the creation of general-purpose computers which were not hardcoded to do their one job
- Abstractly, was developed as something that can take "code" and cause the effects described by the code.
  - A program that controls a program
- Definition
  - "A program that acts as an intermediary between a computer user (AKA the program) and the computer hardware."
  - [[https://en.wikipedia.org/wiki/Operating_system][Wikipedia]]: "An operating system (OS) is system software that manages computer hardware, software resources, and provides common services for computer programs."
    - "System software" which comes with the system, and does not interact directly with the user
    - Hardware: physical objects
    - Software: virtual objects
    - "Common services": providing tools that allow interaction with the hardware
      - [[id:FAAB67BF-9DDB-4AC3-AA45-472F439686EB][Client-Server Model]]
** Examples
- PC
  - Windows
  - macOS
  - Linux
  - Solaris
  - FreeBSD
- Mobile
  - Android
  - iOS
- Other
  - XBOX, PlayStation

* Batch [[id:D289CD47-38F4-481F-BED1-FEAF25C4D709][OS]]
:PROPERTIES:
:ID:       D9F3E442-3F6C-48DF-A404-283C7A15CFBA
:END:
- Run user program (jobs) one at a time

* Multiprogramming
:PROPERTIES:
:ID:       70308734-2797-4277-9DF1-5A145F773AC7
:END:

* Time Sharing [[id:D289CD47-38F4-481F-BED1-FEAF25C4D709][OS]]
:PROPERTIES:
:ID:       6276534B-2CDD-4F8B-BD8A-73DDEA2C1A31
:END:
- Allows multiple points of interaction using terminals (teletype, AKA TTY)
- Schedule user jobs
  - Illusion of [[id:62A2FCE1-6909-4C5A-8D25-015D1F2FAAFA][concurrency]]
- Memory management / provisioning between jobs
- CPU time, memory, and storage are split between the [[id:CEED7EB1-C9DD-40C6-ABBF-32D3E41FA6F7][users]].
*** Examples
- CTSS at MIT, 1960s
- Multics, 1970s


* [[id:D289CD47-38F4-481F-BED1-FEAF25C4D709][OS]] Implementations
:PROPERTIES:
:ID:       28C8C09A-0B31-4354-AD0F-FE83226939E9
:END:
** OS For Mainframes
:PROPERTIES:
:ID:       A1AF2D25-EF35-45E0-A085-9487826DD8B7
:END:
*** IBM360
:PROPERTIES:
:ID:       8A913B91-E03C-4348-9AF3-9FE55CA7290D
:END:
- International Business Machines
- Programmed using punchcards
- The [[id:D289CD47-38F4-481F-BED1-FEAF25C4D709][OS]]:
  - [[id:D9F3E442-3F6C-48DF-A404-283C7A15CFBA][Batch OS]]
  - Still interact with hardware directly
  - Code gains some additional information from the OS

*** Improvements
- CPU is idle when doing I/O, so we should run other tasks
- [[id:70308734-2797-4277-9DF1-5A145F773AC7][Multiprogramming]]
- [[id:6276534B-2CDD-4F8B-BD8A-73DDEA2C1A31][Time Sharing OS]]

** Minicomputer
- A smaller mainframe, adopting the same ideas about the [[id:A1AF2D25-EF35-45E0-A085-9487826DD8B7][OS]]
- Adoption of [[id:C4CA2869-8F42-446C-A25A-570E4765A00C][UNIX]], developed by AT&T

*** Examples
- PDP-11, 1970

* Client-Server Model
:PROPERTIES:
:ID:       FAAB67BF-9DDB-4AC3-AA45-472F439686EB
:END:
- A server acts as an intermediary between a client and another interface.
  - In the case of the OS, the clients are the programs and the interfaces are the hardware.

* Concurrency
:PROPERTIES:
:ID:       62A2FCE1-6909-4C5A-8D25-015D1F2FAAFA
:END:
- Jobs can be "active" at the same time, which means that the CPU can be processing multiple jobs at the same time.
- Note that this is not the same as parallel running.

* Users
:PROPERTIES:
:ID:       CEED7EB1-C9DD-40C6-ABBF-32D3E41FA6F7
:END:
- In the context of [[id:D289CD47-38F4-481F-BED1-FEAF25C4D709][OS]], the "user" is either the actual person, or the program that they are running.

* UNIX
:PROPERTIES:
:ID:       C4CA2869-8F42-446C-A25A-570E4765A00C
:END:
- An operating system developed by AT&T
- Inspired GNU/Linux, which is not UNIX

* Motivations for [[id:D289CD47-38F4-481F-BED1-FEAF25C4D709][OS]]
:PROPERTIES:
:ID:       187C6FEC-1472-4AC3-9C78-CD345A297436
:END:

** Abstraction
:PROPERTIES:
:ID:       F81C54C3-E2DF-4E15-9679-0FA58A23E3B0
:END:
- Hide low-level details from the [[id:CEED7EB1-C9DD-40C6-ABBF-32D3E41FA6F7][user]]
- User can perform tasks without an understanding of what the OS is doing
- User can perform tasks without caring what the specifics of the hardware is
- Provides
  - Efficiency
  - Programmability
  - Portability

** Resource Allocator
:PROPERTIES:
:ID:       9A7A50F0-44D7-465F-A377-ADDF2D53A8FA
:END:
- Barrier between [[id:CEED7EB1-C9DD-40C6-ABBF-32D3E41FA6F7][users]] and the resources
  - CPU
  - Memory
  - I/O devices
  - Other hardware

** Control Program
:PROPERTIES:
:ID:       760712ED-0C18-4C5E-A5E7-B3B1770D6E92
:END:
- Prevent programs from misusing the computer
  - Both accidentally (due to bugs)
  - And purposely (viruses)
- Ensure isolation between the multiple [[id:CEED7EB1-C9DD-40C6-ABBF-32D3E41FA6F7][users]].
- Control execution of the programs
  - Security
  - Isolation
  - Protection
  - Prevent errors
  - Prevent improper use

* Modern [[id:D289CD47-38F4-481F-BED1-FEAF25C4D709][OS]]
:PROPERTIES:
:ID:       f770e083-fe6b-4e22-ae67-3292bda84695
:END:
- Examples:
  - Desktop
    - Windows
    - macOS
    - Linux
  - Mobile
    - iOS
    - Android
  - Embedded
    - Raspibian
  - RTOS
    - freeRTOS (ESP32 my beloved)
** Features of Modern (Desktop) OS
- Multitasking
  - Concurrent execution of programs on multiple cores
  - # of programs >>> # of cores, how?
  - Switch between programs very fast, just like people
- Multiuser
  - Multiple users can be logged in and use at the same time
- Variety of Hardware
  - Single PCs, shared memory systems (10-100s of processors), ...
** Features of Modern (Mobile) OS
- Customized verson of PC OS which has software dedicated to mobile haredware such as cellular modems
** Features of Embedded OS
- Operating system which needs to address specialized hardware
- Has to consider more restrictions such as power and hardware
- Not general purpose, only runs in specific environments
- Mostly stored in read only memory
** Features of Real-Time OS
- When applications need to deal with real time input-output data, RTOS is used
  - "Fly by wire", needs to respond instantly to inputs
- Cannot add new software without rewriting the code
- Can be soft (missable) or hard (cannot miss) time constraints
** Features of Distributed OS
- OS for large networks of computers which can be loosly or tightly connected

* OS Structure
:PROPERTIES:
:ID:       8212b8c8-23c8-445a-9cd4-2a9fc44950f9
:END:
- Implementation of [[id:D289CD47-38F4-481F-BED1-FEAF25C4D709][OS]]
- Factors:
  - Flexibility
    - Easy to adapt
  - Robustness
    - Hard to break
  - Maintainability
    - Easy fo sysadmins to change things
  - Performance
    - Low overhead
- Runs in the kernel [[id:79d9b1f3-2e86-41b0-a5a7-d56a31ada65d][Protection Mode]]
- Programs running under the operating system run in the user [[id:79d9b1f3-2e86-41b0-a5a7-d56a31ada65d][Protection Mode]]
- Libraries may directly interact with the hardware, others may talk to the OS instead
- System processes are OS processes that help with the functionality, but may be run under the user [[id:79d9b1f3-2e86-41b0-a5a7-d56a31ada65d][Protection Mode]].
- User programs may also talk to the OS directly, through the library, or directly to the hardware
- [[file:media/os-structure_1.png][OS Structure Diagram]]
* Kernel Organization
:PROPERTIES:
:ID:       dbdda23c-3747-4896-abec-6cd72a98cc93
:END:
- [[id:D289CD47-38F4-481F-BED1-FEAF25C4D709][OS]] also known as the kernel
  - Deals with hardware issues
  - Provides [[id:583386a9-eb89-491c-9de6-11cf052817da][System Call]] interface
  - Special code which allows user programs to use interrupt handlers and device drivers
  - Kernel code does not have access to system calls (of courses), normal libraries, or normal IO
    - "Code targets bare metal"
    - Code written in higher level compiled langauges like C/C++/ðŸ¦€
      - Previously written in assembly
    - Heaviliy hardware dependant
    - How do you debug
    - Code is split into machine independant HLL code, machine depandant HLL code, and assembly code
** Kernel Types
*** Monolithic Kernel
:PROPERTIES:
:ID:       89c5da4b-e47d-46be-b73a-db52dfc13241
:END:
- Large kernel which includes most of the non-user code running on the computer
- Drivers run within the monolith, which can cause BSOD/Crashes
- [[file:media/monolithic-kernel_1.png][Monolithic Kernel]]
*** Microkernel
:PROPERTIES:
:ID:       f932193f-1834-49e7-b2fa-631d4f008cec
:END:
- Small and clean
- Only essential services
- Other services are ran outside the kernel to provide resiliance
- [[file:media/microkernel_1.png][Microkernel]]

* Protection Mode
:PROPERTIES:
:ID:       79d9b1f3-2e86-41b0-a5a7-d56a31ada65d
:END:
- Hardware enforces protection modes which allow some instructions to only be run by certain privieged programs
- In a coarse overview, there are kernel and user modes
* VMs
:PROPERTIES:
:ID:       2240ad3a-9c58-44ab-adc8-f53388009f72
:END:
- What if you want to run more than one [[id:D289CD47-38F4-481F-BED1-FEAF25C4D709][Operating System]]?
- Use a virtual machine
- Virtualizes some underlying hardware that the OS expects
  - The layer in charge of this is called the [[id:a8b405f0-555f-43d2-af3f-93a38a43dd5c][Hypervisor]]
* Hypervisor
:PROPERTIES:
:ID:       a8b405f0-555f-43d2-af3f-93a38a43dd5c
:END:
- Type one hypervisor OS
  - Runs directly on the OS, may be stored in the ROM or BIOS
  - [[file:media/type-1-hypervisor_1.png][Type 1 Hypervisor]]
- Type two hypervisor
  - Runs above the OS
  - [[file:media/type-2-hypervisor_2.png][Type 2 Hypervisor]]
- WSL
- Docker/Kubernetes (container engines)

* Process Abstraction
:PROPERTIES:
:ID:       bbf11da3-2536-43e2-b1d7-93c46b3bf3ba
:END:
- Work queue
  - Workers take work from a work queue and execute them
- Master-slave
  - A main unit instructs worker units to work on different tasks
* Program Execution
:PROPERTIES:
:ID:       8245e915-ceba-4c96-9183-ce12f38f7b31
:END:
- Memory space is split amongst the different requirements of the program
- [[file:media/memory_1.png][Memory]]
- *Executable file format stores the instruction to the [[id:D289CD47-38F4-481F-BED1-FEAF25C4D709][OS]] on how to construct the process*
  - The file is a blueprint for the processes
  - Contains Instructions and Data
  - What address is the program located at?
  - During runtime, it also contains:
    - Text and Data (memory context)
** Hardware Layout
:PROPERTIES:
:ID:       2a0d3e9a-b060-4725-9cd2-882e52a9c356
:END:
- Memory is slower than registers
- Memory cache is used to speed up memory access
  - SRAM close (inside) the CPU
- Fetch unit grabs data from memory into the registers
  - Program Counter to indicate current program
- Registers come in general and special
  - General is used by programs to store data for instructions
  - Special is used for specific purpose
    - Stack Pointer
    - Program Counter
    - Frame Pointer
- [[file:media/hardware_1.png][Hardware]]
** Function Call
:PROPERTIES:
:ID:       8b9d71e1-fde5-4517-999a-64f413207b37
:END:
- Problems we need to solve:
  - How do we allocate data for the variables?
  - Where do we put the function such that it won't get mixed up?
- Caller function calls the Callee
  - Jump to the function body
  - Execute
  - Jump back to the original location
  - On the way, we need to store parameters and outputs
- These give rise to using a stack to store data
- In the stack, there will be a region called the [[id:1e0a4e58-4815-44c6-8872-000dd5c6e8b4][Stack Frame]]
- A stack pointer points to the top of the [[id:22f8b191-cc90-4c01-b9f5-10f78d597b42][Stack]]
- Basic Linkage
  - As calls are created, data is created on a stack
    - Command jump and link "jal" is used to jump to the callee and save the PC of the caller
    - Arguments stored in argument registers or the stack
  - As calls return, data is popped back off the stack
    - Jump back to the ra register
    - ra register must be saved if you want to further call a function
    - Save return values in return registers or the stack
    - Push back callee saved registers from the stack
- Frame-based linkage
  - The callee must:
    - Allocate space on the stack by creating a frame pointer with enough space to store all its variables, then move the stack pointer to where the frame pointer is
    - Stack may continue to grow if other functions are called
    - Finally, restore fp to the orginal value (since it is callee-saved) by adding to the stack pointer and storing in the frame pointer
  - This gives the function stack space to store variables
- The methods differ based on hardware and programming language, but must preserve certain states
  - This is known as the calling convention and must be consistant
** Stack
:PROPERTIES:
:ID:       22f8b191-cc90-4c01-b9f5-10f78d597b42
:END:
- A FIFO list
- Grows in one direction
- A stack pointer points to the top
- Composed by [[id:1e0a4e58-4815-44c6-8872-000dd5c6e8b4][Stack Frames]]
** Stack Frame
:PROPERTIES:
:ID:       1e0a4e58-4815-44c6-8872-000dd5c6e8b4
:END:
- Stores things like
  - Return address
  - Arguments
  - Local variable storage
  - Register data

* Least Significant Byte
:PROPERTIES:
:ID:       6a212478-657e-4121-a5f2-ad26de5cf35e
:ROAM_ALIASES: LSB
:END:
- The "smallest contributer" to a byte
- In 0xdeadbeef, it is 0xef

* Most Significant Byte
:PROPERTIES:
:ID:       0a64e439-8706-4401-ab6a-71577970d7aa
:ROAM_ALIASES: MSB
:END:
- The "largest contributer" to a byte
- IN 0xdeadbeef, it is 0xde

* Dynamically Alllocated Memory
:PROPERTIES:
:ID:       16e4886a-101b-4cf9-8e9d-f979234176b1
:END:
- When the scope of the data spans many procedure calls, you need dynamic allocation
- Lifetime can be as long as needed
- Languages:
  - C: malloc()
  - C++: new
  - Java: new
- Unlike local data: requires lifetime not tied to a process
- Unlike global data: needs to be allocated at runtime
- Solution: use heap
  - Heap is on the same side as the data and text of the program, and grows towards the stack (On Linux, heap grows towards higher addresses, downward in diagrams, stack grows towards lower addresses, upward in diagrams)
    - If they meet, too bad
  - Allocate heap space requires variable sizing, with variable allocation or deallocation timing
  - Create gaps during allocation
* Process
:PROPERTIES:
:ID:       f77c8ce6-2418-40ea-9cf2-0759fe185dfb
:END:
- A process is a dynamic abstraction for an executing program
- Includes
  - Memory Context
    - Code(Text), Data, Stack, Heap
    - All programs think they are running at memory location 0, but the OS has abstracted it out and virtualized another location in the memory
  - Hardware Context
    - Registers, Program counter, Stack pointer, Stack frame pointer
  - [[id:D289CD47-38F4-481F-BED1-FEAF25C4D709][OS]] Context
    - [[id:82259759-8435-4702-872d-c5ba1e790a2d][Process Management]] Properties
    - Resources used
* Process Management
:PROPERTIES:
:ID:       82259759-8435-4702-872d-c5ba1e790a2d
:END:
- The [[id:D289CD47-38F4-481F-BED1-FEAF25C4D709][OS]] must be able to switch between programs
- [[id:f77c8ce6-2418-40ea-9cf2-0759fe185dfb][Process]] vs code
  - Code is just data on the hard disk
  - Processes are running code with allocated resources
** Process Identification
:PROPERTIES:
:ID:       1fa862c5-7ef2-4084-a884-b3f5e3f6f831
:ROAM_ALIASES: PID
:END:
- An unique ID number to distinguish two processes
- Issues:
  - Are they reused?
  - Does it limit the maximum number of processes?
  - Are there reserved PIDs?
** Process State
:PROPERTIES:
:ID:       3925466a-d2e6-4534-af63-0198ec7c2f90
:END:
- In multitasking, a [[id:f77c8ce6-2418-40ea-9cf2-0759fe185dfb][Process]] can be:
  - Running
  - Not running
- The OS may run as a separate process or along with the current process
- A [[id:f77c8ce6-2418-40ea-9cf2-0759fe185dfb][Process]] can also be Ready to run
- Each process has an associated process state associated with it
- [[file:media/5-state-process_1.png][5 State Process Model]]
  - Create
    - OS records information such as the memory context of the new process
    - "Creation process"
  - Admit
    - Process initialized
    - Ready to run
  - Scheduled
    - OS gives the CPU to the process
  - Release
    - The program or OS returns control back to the OS
  - Wait
    - The program signals that it needs an event to occur in order to continue
  - Event occurs
    - Pulls a process out of the blocked state into the ready state, meaning the event has occured and the program can continue execution
  - Exit
    - Program is done
  - New
    - Process just created
    - May still be initializing
  - Ready
    - Process is waiting to run on the CPU
  - Running
    - Process is running on the CPU
  - Blocked
    - The program is waiting for an event, it is not ready
    - Generally waiting for IO
    - Could also be waiting for a child process
  - Terminate
    - The OS must clear out the allocated resources to be used elsewhere
    - "Teardown process"
** Multicore management
:PROPERTIES:
:ID:       e3f37058-ba20-498b-b7d7-a6b17fd9a4eb
:END:
- With only 1 core, there is 1 running process and 1 transition at one time
- With m cores, there can be up to m running processes and multiple transitions
- Assumption in [[id:15F9BA90-8952-47DC-A1E9-951A8D12D158][CS2106]]: SINGLE CORE
** Process Queueing
:PROPERTIES:
:ID:       29fcb90f-8ae3-4196-b634-74412dc6b403
:END:
- [[file:media/process-queue_1.png][Process Queue]]
- Two queues: ready queue and blocked queue
** Process Creation
:PROPERTIES:
:ID:       9d9878a2-8dc4-44b5-93d8-f3d65c2f18b9
:ROAM_ALIASES: Forking
:END:
- AKA "Forking"
- To create a new [[id:f77c8ce6-2418-40ea-9cf2-0759fe185dfb][Process]],
  - Clone yourself
  - Lay out the new process using the instructions from the executable
- In Linux, the fork and exec [[id:583386a9-eb89-491c-9de6-11cf052817da][Syscalls]] are used
- [[file:media/fork-c_1.png][Fork = Clone]]
  - The program state is exactly copied at the point in time after the fork call
  - Only difference is the return value of fork. The parent process will get the PID of the child, the child gets nothing
  - Use ~exec()~ to change to another executable
  - Use copy-on-write to prevent unnecessary cloning of information
- Parents should "reap" their child processes before exiting to cleanup
  - In C, the function is ~wait()~
  - NOTE: ~wait()~ does not block if there are no child processes to wait for ([[id:15F9BA90-8952-47DC-A1E9-951A8D12D158][CS2106 Exam]])
- A process will only have one parent unless,
  - Debugging: the child process could be a surrogate parent to another child (the debugger "attaches" to the process)
  - Parent killed: orphan processes will attach to another child process
  - Parent doesn't wait: child becomes a zombie process which isn't properly cleaned up
** Process Tree
:PROPERTIES:
:ID:       07f63771-0d15-43cb-b1d6-a9d59c2bd3bd
:END:
- ~pstree~ command in Linux
- Every process except a single parent process is a child of another process, giving rise to a tree
- The "mother of all processes" is that parent, in some Linux systems, it is Systemd.
** Process Control Block
:PROPERTIES:
:ID:       936f40d0-ff0e-4680-a31b-cd08d9ecf5e1
:ROAM_ALIASES: PCB "Process Table Entry"
:END:
- A block of data containing the entire execution context of a [[id:f77c8ce6-2418-40ea-9cf2-0759fe185dfb][Process]].
- Contains hardware, memory, and [[id:D289CD47-38F4-481F-BED1-FEAF25C4D709][OS]] contexts.
** Process Table
:PROPERTIES:
:ID:       0a67a841-29cc-4614-a951-cf4e747e01f5
:ROAM_ALIASES: PCB
:END:
- The kernel stores [[id:0a67a841-29cc-4614-a951-cf4e747e01f5][PCBs]] for all processes
- Issues:
  - Scalability: how many processes can you run at the same time?
  - Efficiency: efficient access to PCBs vs space usage
- [[file:media/process-table_1.png][Process Table]]
* System Calls
:PROPERTIES:
:ID:       583386a9-eb89-491c-9de6-11cf052817da
:ROAM_ALIASES: Syscalls
:END:
- An API to interact with the [[id:D289CD47-38F4-481F-BED1-FEAF25C4D709][OS]]
- Provides a way to call facilities or services existing in the kernel
- *NOT* the same as a normal function call
  - Requires [[id:79d9b1f3-2e86-41b0-a5a7-d56a31ada65d][Kernel Mode]]
- OS Dependent
  - UNIX: ~100 syscalls
  - Windows: ~1000 syscalls
- Languages
  - C/C++ can almost directly use syscalls
    - For example, ~getpid()~, or ~printf~ which calls ~write~ under the hood
    - These functions are provided by GNU LIBC
** Invoking System Calls
:PROPERTIES:
:ID:       b13d6413-611f-4c38-8930-7db3548bb23b
:END:
- User program invokes the library call
- Library call places the system call number in the correct register
- Library call executes a special instruction to enter [[id:79d9b1f3-2e86-41b0-a5a7-d56a31ada65d][Kernel Mode]]
  - Instruction is usually called TRAP
- In the kernel mode, the system call handler is determined based on the value in the register
  - Uses the value as an index for searching for the appropriate handler
  - Handled by a "dispatcher"
- System call is executed
- System call handler ends
  - Return control to the calling library
  - Switch back to user mode
- Library call returns to the user program
- [[file:media/syscall-process_1.png][Syscall Process]]
* Handler Routines
:PROPERTIES:
:ID:       50712286-ce75-4c85-b77c-218514d2ab5e
:END:
- After an interruption:
- [[file:media/interrupt_1.png][Interruption]]
- The hardware will transfer control to the handler routine
- Program execution may resume
** Exceptions
:PROPERTIES:
:ID:       c2323338-f9ba-4ba0-bf10-1c0d94151b37
:END:
- Sometimes machine level instructions can cause errors
- Examples:
  - Divide by 0
  - Illegal address access
- The hardware will force a [[id:583386a9-eb89-491c-9de6-11cf052817da][Syscall]] execute the exception handler
- Execution is synchronous, i.e. right after the error
** Event Handler
:PROPERTIES:
:ID:       3e26cb31-e015-4a89-ba3e-4cdbcedefafa
:END:
- External events may interrupt a program
- Usually hardware inputs
- Interrupts are asynchronous, meaning that it happens outside of program execution flow
- The interrupt handler will be called
* Concurrent Execution
:PROPERTIES:
:ID:       5f016241-05b6-4c76-b61f-a06964ed1e88
:END:
- Concurrent processes are processes that multiple processes can progress in execution at the same time
- Could be virtual parallelism: illusion of process running at the same time
  - AKA [[id:adfa430b-a10a-4e21-8025-cd95f5a8ecb2][Timeslicing]]
- Could be physical parallelism: processes are actually running at the same time on multiple CPUs
  - AKA [[id:adfa430b-a10a-4e21-8025-cd95f5a8ecb2][Timeslicing]] on multiple processors

* Timeslicing
:PROPERTIES:
:ID:       adfa430b-a10a-4e21-8025-cd95f5a8ecb2
:END:
- [[file:media/interleaved-execution_1.png][Interleaved Execution]]
- Sharing a CPU's time amongst many processes
- Every time you switch processes, the [[id:D289CD47-38F4-481F-BED1-FEAF25C4D709][OS]] needs to decide which [[id:f77c8ce6-2418-40ea-9cf2-0759fe185dfb][Process]] to switch to
  - Involves an overhead with context switching
- Problems
  - What happens when you have more processes to run than you do CPUs? Then how do you choose which to run?
    - This is known as the scheduling problem
    - Scheduler: the part of the OS which makes the decision
    - [[id:330baf6a-5e30-4f41-8847-f9eddf19f71e][Scheduling Algorithm]]: the algorithm used by the scheduler
** Scheduling Algorithm
:PROPERTIES:
:ID:       330baf6a-5e30-4f41-8847-f9eddf19f71e
:END:
 - Need to consider the amount of CPU time required by each process
 - Divide the processes into two classes:
   - CPU-Activity, most time is spent doing calculations
   - IO-Activity, most time is spent waiting for IO
 - Type of process:
   - Batch, low priority because no user interaction is required, no responsivity requirements
   - Interactive, should be responsive to user
   - Real time processing, has a deadline for something to be completed
 - The algorithm may be influenced by the current processing enviroment, but it has to balance between conflicting criteria:
   - Fairness, each process should get enough CPU time, no process should be starved
     - Applies per user or per process
   - Utilization, all parts of the computing system should be constantly in use
 - Two types of scheduling policies:
   - Non-preemptive (cooperative)
     - Process will stay scheduled until it blocks or yields to other processes
   - Preemptive
     - Process will be evicted based on its time quota, it will be removed whether or not it blocks once the timer is up.
     - The OS will come in even when there is only one process
*** Scheduling for Batch Processing Systems
- Criteria:
  - Turnaround time (finish time - arrival time)
  - Throughput (how many tasks per time)
  - Makespan (total time for all tasks, only applicable when the set of tasks is fixed)
  - CPU utilization (percent of time when CPU is working on tasks)
- Generally easier to implement and understand
  - First come first serve
    - Tasks stored in a Queue data structure based on arrival time
    - Run the first task in the queue to block, yield, or completion
    - Place the task to the back of the queue if it is not completed
    - Guarantees no starvation as the number of tasks left to run before a process gets the CPU is always decreasing
    - Averge waiting time can be further optimized by reorganizing
      - Convoy Effect
      - If I/O-bound tasks are queued after CPU-bound tasks, then the I/O bound tasks are idling when they could be waiting on I/O if given a short amount of time to run
  - Shortest job first
    - Select tasks with smallest CPU time
    - May not be known, sometimes musst be guessed at
      - Common approach is exponential average
        - $P_{n+1}=wA_n +(1-w)P_n$
        - Where P = prediction, A = actual, and w is how we weight the actual vs the prediction
    - Good for minimizing average wait time
    - May starve long jobs if shorter jobs are consistently being added
      - In fact, being able to not starve the longest job requires the CPU to be exacty at or less than full utilization compared to the volume of tasks coming in
  - Shortest remaining time
    - Variation of shortest job first with preemtion
    - If a new job is added with a shorter remaining time, the current process may be evicted to run it.
    - Allows short jobs arriving later to not have to wait for longer jobs
*** Scheduling for Interactive Systems
- Criteria:
  - Response Time (time between requests and response)
  - Predictability (low variance in wait time)
- Utilizes preemtive scheduling by creating timer based interrupt to hand control over to the OS
- Algorithms:
  - Round Robin
    - All tasks are stored in a FIFO queue
    - When each task blocks, yields, or completes, we evict it from the CPU
    - The task is moved to the back of the queue if it is not completed
    - Guarantees each tasks can get some CPU time every $q(n-1)$ units, where q is the [[id:1fd3da26-d080-477b-b2bd-da4a0c914a09][Time Quantum]] and n is the number of tasks
    - [[id:b3ef1808-f8f2-4f6b-89a3-c9dfb5046182][ITI]] and [[id:1fd3da26-d080-477b-b2bd-da4a0c914a09][Time Quantum]] must be carefully chosen
  - Priority Scheduling
    - Some tasks are more important than others
    - Assign priority to each process
      - (Always clarify whether low number or high number have higher priority)
    - Select tasks with higher priority to run first
    - May starve low priority tasks
    - Possible solutions:
      - Decrease the priority every time quantum
      - Don't consider the process for the next round of scheduling
    - Hard to guarantee the amount of CPU time given to a process using priority
    - [[id:a0007235-a2a1-4d4f-99f7-99fbe63ededc][Priority Inversion]]
  - Multilevel Feedback Queue
    - How do we schedule without perfect knowledge?
    - Learn along the way
    - Minimize both Response time for IO bound process, and turnaround time for CPU bound process
    - Basic Rules:
      - If Priority(A)>Priority(B), then A should run
      - If Priority(A)=Priority(B), then they run in round robin
    - Priority setting/changing
      - New jobs given maximum priority
      - If a job fully uses the [[id:1fd3da26-d080-477b-b2bd-da4a0c914a09][Time Quantum]], then its priority is reduced
      - Otherwise, no change
      - In some systems, when tasks are dropped to the lowest priority then some are re-elevated
  - Lottery Scheduling
    - Give lottery ticket for each process for each resource
    - For each scheduling decision, randomly choose one ticket to grant that process
    - In the long run, a process with X% of the tickets for a resource can use the resource X% of the time
    - Lottery tickets can be distributed to children
    - Important process given more tickets
    - Each resource has its own set of tickets
** Scheduling Process
:PROPERTIES:
:ID:       6809f87c-1a74-4932-9d98-141bd54e191b
:END:
- When schedule is triggered:
  1. [[id:D289CD47-38F4-481F-BED1-FEAF25C4D709][OS]] decides if context switching is necessary
  2. The OS picks a suitable process to run next, based on the [[id:330baf6a-5e30-4f41-8847-f9eddf19f71e][Scheduling Algorithm]]
  3. The OS sets up the context for the [[id:f77c8ce6-2418-40ea-9cf2-0759fe185dfb][Process]]
  4. Process is allowed to run
* Interval of Timer Interrupt
:PROPERTIES:
:ID:       b3ef1808-f8f2-4f6b-89a3-c9dfb5046182
:ROAM_ALIASES: ITI
:END:
- How long between when the [[id:D289CD47-38F4-481F-BED1-FEAF25C4D709][OS]] is handed control.
- Generally 1-10ms.
- Decreasing it increases overhead
* Time Quantum
:PROPERTIES:
:ID:       1fd3da26-d080-477b-b2bd-da4a0c914a09
:END:
- How long each task is given to run on the CPU.
- Generally 5-100ms.
- Decreasing it increases overhead but increases responsiveness
* Priority Inversion
:PROPERTIES:
:ID:       a0007235-a2a1-4d4f-99f7-99fbe63ededc
:END:
- Occurs when a resource is locked by a lower priority process, which is then supersceded and unable to unlock the resource
- Then, high priority tasks which needs that resource cannot run and lower priority tasks will be run instead
* Isolation vs Cooperation
:PROPERTIES:
:ID:       805bb2b2-1af9-46fe-9af1-04b2c13e0f4d
:END:
- Under the OS, processes run as if it is the only process in the system
- Sometimes processes must cooperate and send data
  - Share nothing (client server model)
  - Shared memory (may be prone to abuse or accidents)
- Solution: use [[id:5eb73086-a3c9-43f2-98a6-c864225b6ef3][IPC]]
* Inter-Process Communication
:PROPERTIES:
:ID:       5eb73086-a3c9-43f2-98a6-c864225b6ef3
:ROAM_ALIASES: IPC
:END:
- Mechanisms introduced in Unix System V
  - Shared memory
  - Message passing
  - Semaphores
** Shared Memory
:PROPERTIES:
:ID:       25e99b54-148b-41c1-9a5e-105bf59c80fd
:END:
- A process creates a shared memory region
- That shared memory region is appended to another process' memory
  - The virtual address for the memory region is not guaranteed to be the same across processes
- Processes can now write and read to the memory in order to communicate
- OS only needs to manage the creation and sending of shared memory region to other processes, rest is done by processes
- Pros:
  - Efficient (OS has very little to do)
  - Easy to Use (behaves like normal memory)
- Cons:
  - Synchronization: requires locks and ordering
  - Implementation is harder
** Message Passing
:PROPERTIES:
:ID:       c6ff3ba9-c369-40d7-8123-d2418df8930b
:END:
- Simply give a function which allows processes to send messages to other processes
- Message first stored in OS memory space
- Processes must know some way to identify the other
  - Direct communication: sockets
    - Sender and receiver knows the socket / name of the other
    - One link per pair of processes
    - Need to know the ID of the other party
  - Indirect communication: mailbox/port
    - Processes deposit and read messagefs from mailboxes
    - Mailbox can be shared
- Can block (synchronous) to wait for a message, or not (asynchronous) and just check if the message is there to receive.
- Pros:
  - Synchronization: each process knows that a message has actually been sent, whereas in shared memory each process may be unsure if the message has been sent
  - Portable: Conceptually can be extended to different environments, such as over a network
- Cons:
  - Inefficient: needs OS intervention and copying of messages
